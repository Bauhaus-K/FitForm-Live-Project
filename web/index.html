<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>MyPT Azure â€“ On-device Pose Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- í°íŠ¸ & ê¸°ë³¸ ìŠ¤íƒ€ì¼ -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --bg: #020817;
        --card: #020617;
        --card-soft: #020617;
        --accent: #38bdf8;
        --accent-soft: rgba(56, 189, 248, 0.1);
        --text: #e5e7eb;
        --muted: #9ca3af;
        --danger: #f97373;
        --good: #22c55e;
        --border: #1f2937;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Pretendard", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background: radial-gradient(circle at top, #020617, #000);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }

      .page {
        width: 100%;
        max-width: 1200px;
        padding: 32px 16px 64px;
      }

      header {
        margin-bottom: 24px;
      }

      .title-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
      }

      .title-row span.emoji {
        font-size: 32px;
      }

      h1 {
        font-size: 32px;
        margin: 0;
        font-weight: 700;
      }

      .subtitle {
        color: var(--muted);
        font-size: 15px;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .video-shell {
        background: radial-gradient(circle at top left, #020617, #020617 40%);
        border-radius: 24px;
        border: 1px solid var(--border);
        padding: 16px 16px 24px;
        box-shadow: 0 40px 80px rgba(0, 0, 0, 0.8);
      }

      .video-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        gap: 8px;
      }

      .video-toolbar-left {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .pill {
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        font-size: 11px;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .pill-dot {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: #22c55e;
      }

      .exercise-select,
      .character-select {
        background: #020617;
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 6px 10px;
        color: var(--text);
        font-size: 13px;
      }

      .exercise-select select,
      .character-select select {
        background: transparent;
        border: none;
        color: inherit;
        font: inherit;
        outline: none;
        padding: 6px 28px 6px 10px;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        cursor: pointer;
      }

      .exercise-select::after,
      .character-select::after {
        content: "â–¼";
        font-size: 10px;
        color: var(--muted);
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
      }

      .current-exercise-display {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid var(--border);
        font-size: 13px;
        color: var(--muted);
      }

      .current-ex-label {
        font-weight: 500;
        color: var(--muted);
      }

      #current-exercise-name {
        color: var(--text);
        font-weight: 600;
      }

      #exercise-picker-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.92);
        color: white;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease-out;
        z-index: 20;
      }

      .exercise-picker-panel {
        max-width: 760px;
        width: 90%;
        max-height: 80%;
        overflow-y: auto;
        padding: 24px 24px 20px;
        border-radius: 20px;
        background: rgba(15, 23, 42, 0.98);
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.9);
      }

      .exercise-picker-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }

      .exercise-picker-title {
        font-size: 18px;
        font-weight: 700;
        margin: 0;
      }

      .exercise-picker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
      }

      .exercise-card {
        padding: 14px 14px 12px;
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.35);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .exercise-card-title {
        font-size: 15px;
        font-weight: 600;
        margin: 0 0 2px;
      }

      .exercise-type-tag {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.12);
        border: 1px solid rgba(56, 189, 248, 0.3);
        font-size: 11px;
        color: #e0f2fe;
      }

      .exercise-short {
        font-size: 12px;
        color: var(--muted);
        margin: 2px 0 8px;
      }

      .exercise-card .btn {
        align-self: flex-start;
        font-size: 12px;
        padding: 5px 10px;
      }

      .video-wrapper {
        position: relative;
        border-radius: 18px;
        overflow: hidden;
        background: #020617;
        border: 1px solid #020617;
        aspect-ratio: 16 / 9;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #video,
      #canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1); /* ì…€ì¹´ì²˜ëŸ¼ ì¢Œìš° ë°˜ì „ */
      }

      canvas {
        pointer-events: none;
      }

      .hud-card {
        position: absolute;
        left: 24px;
        bottom: 24px;
        background: rgba(15, 23, 42, 0.96);
        border-radius: 18px;
        padding: 16px 18px 14px;
        min-width: 220px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        backdrop-filter: blur(16px);
        box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
      }

      .hud-title {
        font-size: 15px;
        font-weight: 600;
        margin-bottom: 4px;
      }

      .hud-row {
        display: flex;
        gap: 12px;
        font-size: 13px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .hud-row strong {
        color: var(--text);
        font-weight: 600;
        margin-left: 2px;
      }

      .status-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        margin-bottom: 10px;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #4b5563;
      }

      .status-dot.good {
        background: var(--good);
      }

      .status-dot.bad {
        background: var(--danger);
      }

      .status-text {
        color: var(--muted);
      }

      .status-text strong {
        color: var(--text);
        font-weight: 600;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 7px 14px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: linear-gradient(135deg, #0ea5e9, #22c55e);
        color: white;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        outline: none;
      }

      .btn.secondary {
        background: rgba(15, 23, 42, 0.9);
        border-color: rgba(148, 163, 184, 0.5);
        color: var(--text);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: default;
      }

      .top-menu {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 0 14px;
        margin-bottom: 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        position: sticky;
        top: 0;
        z-index: 30;
        backdrop-filter: blur(16px);
        background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
      }

      .top-menu .btn.secondary {
        padding: 6px 12px;
        font-size: 13px;
        white-space: nowrap;
      }

      .top-menu .btn.secondary.active {
        background: linear-gradient(135deg, #0ea5e9, #22c55e);
        color: #ffffff;
        border-color: rgba(56, 189, 248, 0.8);
      }

      .challenge-timer.active {
        background: linear-gradient(135deg, #0ea5e9, #22c55e);
        color: #ffffff;
        border-color: rgba(56, 189, 248, 0.8);
      }

      .workout-row {
        display: flex;
        gap: 16px;
        align-items: flex-start;
      }

      #training-view {
        flex: 2;
      }

      #challenge-view {
        position: absolute;
        right: 24px;
        bottom: 24px;
        display: none;
      }

      @media (max-width: 768px) {
        .page {
          padding-inline: 12px;
        }
        h1 {
          font-size: 24px;
        }
        .hud-card {
          left: 14px;
          bottom: 14px;
        }
        .top-menu {
          overflow-x: auto;
          padding-bottom: 10px;
        }
      }
    </style>

    <!-- Import Map for Module Resolution -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
      }
    }
    </script>

    <!-- TensorFlow.js + MoveNet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
  
      <!-- Azure Speech SDK for TTS -->
    <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
  </head>

  <body>
    <div class="page">
      <header>
        <div class="title-row">
          <span class="emoji">ğŸ‹ï¸â€â™‚ï¸</span>
          <h1>FIT FORM LIVE - í—¬ë¦°ì´ë¥¼ ìœ„í•œ AI PT</h1>
        </div>
        <p class="subtitle">
          Microsoft AI School 8ê¸° 1ì°¨ í”„ë¡œì íŠ¸ 7íŒ€ [ê¹€íƒœí›ˆ, ê³ ì˜í›„, ì´ì¬ì›…, ì´ë™í˜„, ì´ëˆ„ë¦¬, í—ˆì§„í˜¸]
        </p>
      </header>
      <nav id="top-menu" class="top-menu">
        <button class="btn secondary" id="menu-training">íŠ¸ë ˆì´ë‹ ëª¨ë“œ</button>
        <button class="btn secondary" id="menu-avatar">ì•„ë°”íƒ€ ëª¨ë“œ</button>
        <button class="btn secondary" id="menu-challenge">ë„ì „ ëª¨ë“œ</button>
        <button class="btn secondary" id="menu-dev">ê°œë°œì ë„êµ¬</button>
      </nav>

      <main>
        <div id="workout-row" class="workout-row">
          <div id="training-view">
            <section class="video-shell">
              <div class="video-toolbar">
                <div class="video-toolbar-left">
                  <div class="pill">
                    <span class="pill-dot"></span>
                    <span id="model-label">MoveNet Lightning Â· On-device</span>
                  </div>

                  <div class="current-exercise-display">
                    <span class="current-ex-label">í˜„ì¬ ìˆ˜í–‰ ë™ì‘:</span>
                    <span id="current-exercise-name">Right Arm Curl</span>
                  </div>
                  <button id="open-exercise-picker" class="btn secondary" style="margin-left: 8px;">ìˆ˜í–‰ ë™ì‘ ì„ íƒ</button>
                  <div class="character-select" id="avatar-style-wrapper" style="display:none; margin-left:8px; position:relative;">
                    <select id="avatar-style-select">
                      <option value="basic">ë‚¨ì„±</option>
                      <option value="cute">ì—¬ì„±</option>
                    </select>
                  </div>
                </div>

                <div style="display: flex; gap: 8px; align-items: center;">
                  <button id="toggle-overlay" class="btn secondary">í¬ì¦ˆì„  ë„ê¸°</button>
                  <button id="toggle-camera" class="btn">ì¹´ë©”ë¼ ì‹œì‘</button>
                </div>
              </div>

              <div class="video-wrapper">
                <div id="camera-layer" style="position:absolute; inset:0;">
                    <video id="video" playsinline></video>
                    <canvas id="canvas"></canvas>
                </div>

                <div id="countdown-overlay" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:72px; font-weight:700; color:white; text-shadow:0 0 16px rgba(0,0,0,0.8); background:rgba(15,23,42,0.45); opacity:0; transition:opacity 0.2s ease-out; pointer-events:none;"></div>
                <div
                  id="rep-overlay"
                  style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:80px; font-weight:800; color:white; text-shadow:0 0 24px rgba(0,0,0,0.9); pointer-events:none; opacity:0; transition:opacity 0.2s ease-out;"
                ></div>

                <div
                  id="summary-overlay"
                  style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(15,23,42,0.9); color:white; opacity:0; pointer-events:none; transition:opacity 0.25s ease-out; z-index:9999">
                  <div
                    style="max-width:420px; padding:24px 28px; border-radius:18px; background:rgba(15,23,42,0.98); border:1px solid rgba(148,163,184,0.4); box-shadow:0 24px 60px rgba(0,0,0,0.8);">
                    <h2 style="margin:0 0 12px; font-size:20px; font-weight:700;">ìš´ë™ ìš”ì•½</h2>
                    <p style="margin:0; font-size:14px; color:#9ca3af;">ìš´ë™ì´ ëë‚˜ë©´ ìš”ì•½ì´ ì—¬ê¸° í‘œì‹œë©ë‹ˆë‹¤.</p>
                  </div>
                </div>

                <div id="exercise-picker-overlay">
                  <div id="exercise-picker-panel" class="exercise-picker-panel">
                    <!-- JSì—ì„œ ìš´ë™ ì¹´ë“œê°€ ë Œë”ë§ë©ë‹ˆë‹¤. -->
                  </div>
                </div>

                <div
                  id="avatar-container"
                  style="position:absolute; inset:0; width:100%; height:100%; background:#0f172a; border-radius:12px; overflow:hidden; display:none;"
                >
                  <!-- Three.js avatar canvas will be injected here in Avatar mode -->
                  <div
                    id="avatar-warning"
                    style="position:absolute; inset:0; display:none; align-items:center; justify-content:center; font-size:18px; color:#e5e7eb; background:rgba(15,23,42,0.6); text-align:center; padding:16px;"
                  >
                    ì „ì‹ ì´ í™”ë©´ì— ëª¨ë‘ ë“¤ì–´ì˜¤ë„ë¡<br />ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë‘ì–´ì£¼ì„¸ìš”.
                  </div>
                </div>

                <div class="hud-card">
                  <div class="hud-title" id="hud-exercise">Right Arm Curl</div>

                  <div class="hud-row">
                    <div>Reps:<strong id="hud-reps">0</strong></div>
                    <div>Angle:<strong id="hud-angle">0Â°</strong></div>
                    <div>FPS:<strong id="hud-fps">0</strong></div>
                  </div>

                  <div class="status-row">
                    <div id="status-dot" class="status-dot"></div>
                    <div class="status-text">
                      ìƒíƒœ: <strong id="status-label">-</strong>
                      <span id="status-detail" style="margin-left: 4px; color: var(--muted);"></span>
                    </div>
                  </div>

                  <button id="start-workout-btn" class="btn">ìš´ë™ ì‹œì‘</button>
                  <button id="reset-btn" class="btn secondary" style="margin-left: 8px;">ì¹´ìš´íŠ¸ ì´ˆê¸°í™”</button>
                </div>
                <div id="challenge-view" style="display:none;">
                  <div style="padding:16px; background:rgba(15,23,42,0.9); border-radius:16px; border:1px solid rgba(148,163,184,0.3);">
                    <h2 style="margin:0 0 8px;">ë„ì „ ëª¨ë“œ íƒ€ì´ë¨¸</h2>
                    <div style="display:flex; gap:8px; flex-wrap:wrap;">
                      <button class="btn secondary challenge-timer" data-minutes="1">1ë¶„</button>
                      <button class="btn secondary challenge-timer" data-minutes="3">3ë¶„</button>
                      <button class="btn secondary challenge-timer" data-minutes="5">5ë¶„</button>
                      <button class="btn secondary challenge-timer" data-minutes="10">10ë¶„</button>
                    </div>
                    <div style="margin-top:12px; font-size:14px; color:#e5e7eb;">
                      ë‚¨ì€ ì‹œê°„: <strong id="challenge-remaining">-</strong>
                    </div>
                  </div>
                </div>
              </div>
            </section>
          </div>

        </div>

        <div id="avatar-view" style="display:none; width:100%; max-width:1200px; margin-top:20px;">
          <div style="padding:16px; background:rgba(15,23,42,0.9); border-radius:16px; border:1px solid rgba(148,163,184,0.3);">
            <h2 style="margin:0 0 8px;">3D ì•„ë°”íƒ€ ëª¨ë“œ</h2>
            <p style="color:#9ca3af; font-size:14px; margin:0;">
              ë‚˜ì˜ ìš´ë™ ë™ì‘ì„ ê·¸ëŒ€ë¡œ ë”°ë¼í•˜ëŠ” 3D ì•„ë°”íƒ€! ê²Œì„ì²˜ëŸ¼ ì¦ê¸°ë©´ì„œ ìì„¸ë¥¼ ì ê²€í•´ë³´ì„¸ìš”.
            </p>
          </div>
        </div>

        <!-- ê°œë°œì ë„êµ¬ ë·° -->
        <div id="dev-view" style="display:none; width:100%; max-width:1200px; margin-top:20px;">
          <div style="padding:16px; background:rgba(15,23,42,0.9); border-radius:16px; border:1px solid rgba(148,163,184,0.3);">
            <h2 style="margin:0 0 12px;">ê°œë°œì ë„êµ¬</h2>
            <p style="color:#9ca3af; font-size:14px; margin:0 0 12px;">
              (Coming Soon for pro user) ì •í™•í•œ ìš´ë™ ìì„¸ì˜ ì¢Œí‘œë¥¼ ML ê¸°ë°˜ìœ¼ë¡œ ë¶„ë¥˜, ì‹œê°í™”í•˜ê³ , ëª¨ë¸ ì„±ëŠ¥ì„ ë¶„ì„í•˜ëŠ” ë„êµ¬ë“¤ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
            </p>
            <pre id="dev-log" style="max-height:260px; overflow:auto; font-size:12px; background:#020617; padding:10px; border-radius:8px; border:1px solid rgba(31,41,55,0.9);"></pre>
          </div>
        </div>
      </main>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      const AVATAR_MODELS = {
        basic: "models/basic.glb",
        cute: "models/cute.glb",
      };

      let avatarScene = null;
      let avatarCamera = null;
      let avatarRenderer = null;
      let avatarModel = null;
      let avatarBoneMap = null;

      // --------------------------
      // 1. ê¸°ë³¸ ìƒíƒœ & ìƒìˆ˜
      // --------------------------
      const videoEl = document.getElementById("video");
      const canvasEl = document.getElementById("canvas");
      const ctx = canvasEl.getContext("2d");

      const hudExercise = document.getElementById("hud-exercise");
      const hudReps = document.getElementById("hud-reps");
      const hudAngle = document.getElementById("hud-angle");
      const hudFps = document.getElementById("hud-fps");
      const statusDot = document.getElementById("status-dot");
      const statusLabel = document.getElementById("status-label");
      const statusDetail = document.getElementById("status-detail");
      const toggleCameraBtn = document.getElementById("toggle-camera");
      const toggleOverlayBtn = document.getElementById("toggle-overlay");
      const resetBtn = document.getElementById("reset-btn");
      const startWorkoutBtn = document.getElementById("start-workout-btn");
      const countdownEl = document.getElementById("countdown-overlay");
      const repOverlayEl = document.getElementById("rep-overlay");
      const summaryOverlayEl = document.getElementById("summary-overlay");
      const currentExerciseNameEl = document.getElementById("current-exercise-name");
      const exercisePickerOverlay = document.getElementById("exercise-picker-overlay");
      const exercisePickerPanel = document.getElementById("exercise-picker-panel");
      const openExercisePickerBtn = document.getElementById("open-exercise-picker");
      const avatarStyleWrapper = document.getElementById("avatar-style-wrapper");
      const avatarStyleSelect = document.getElementById("avatar-style-select");
      const avatarWarningEl = document.getElementById("avatar-warning");

      const avatarCameraBtn = document.getElementById("avatar-camera-btn");

      // ğŸ”Š Azure Speech TTS ìƒíƒœ
      let ttsEnabled = true;
      let isSpeaking = false;
      let speechConfig = null;
      let audioConfig = null;
      let synthesizer = null;
      let pendingText = null;
      let speechInitPromise = null; // initSpeechê°€ í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥

      // ğŸ”Š ìˆ«ì ì¹´ìš´íŠ¸ìš© TTS ìºì‹œ (ì§€ì—° ìµœì†Œí™”)
      let cacheSynthesizer = null; // ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ê¸° ìœ„í•œ TTS ì¸ìŠ¤í„´ìŠ¤
      const ttsCache = {}; // { repNumber: HTMLAudioElement }
      let ttsReady = false;
      let countdownAudio = null; // "5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤" ì „ìš© ì˜¤ë””ì˜¤ ìºì‹œ
      const avatarTtsCache = {}; // ì•„ë°”íƒ€ ëª¨ë“œ ë¬¸ì¥ìš© TTS ìºì‹œ

      async function initSpeech() {
        if (!window.SpeechSDK) {
          console.warn("SpeechSDKê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
          return;
        }
        if (speechConfig && audioConfig && synthesizer) {
          return;
        }
        try {
          const res = await fetch("/api/getspeechtoken");
          if (!res.ok) {
            console.error("Failed to fetch speech token:", res.status);
            return;
          }

          // ë¡œì»¬ Live Serverì—ì„œ 404 HTMLì„ ëŒë ¤ì¤„ ë•Œ JSON íŒŒì‹± ì—ëŸ¬ê°€ ë‚˜ì§€ ì•Šë„ë¡ ë³´í˜¸
          const raw = await res.text();
          let data;
          try {
            data = JSON.parse(raw);
          } catch (e) {
            console.warn(
              "/api/getspeechtoken ì‘ë‹µì´ JSONì´ ì•„ë‹™ë‹ˆë‹¤. (ì•„ë§ˆ ë¡œì»¬ í™˜ê²½) TTS ì´ˆê¸°í™”ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤."
            );
            return;
          }

          if (!data.token || !data.region) {
            console.error("Speech token response invalid:", data);
            return;
          }

          speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(
            data.token,
            data.region
          );
          // í•œêµ­ì–´ ìŒì„±
          speechConfig.speechSynthesisVoiceName = "ko-KR-SunHiNeural";

          // mp3 ì¶œë ¥
          if (SpeechSDK.SpeechSynthesisOutputFormat) {
            speechConfig.speechSynthesisOutputFormat =
              SpeechSDK.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3;
          }

          audioConfig = SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();

          // ë¬¸ì¥ ì•ˆë‚´ìš©
          synthesizer = new SpeechSDK.SpeechSynthesizer(
            speechConfig,
            audioConfig
          );

          // ìˆ«ì TTS ìºì‹œìš© (ì˜¤ë””ì˜¤ ë°ì´í„°ë§Œ ë°›ìŒ)
          cacheSynthesizer = new SpeechSDK.SpeechSynthesizer(
            speechConfig,
            null
          );
          ttsReady = true;

          console.log("Speech TTS initialized.");

          // "5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤." & 1~5 ìˆ«ì ë¯¸ë¦¬ ìºì‹œ
          preloadCountdownAudio();
          preloadNumberRange(1, 5);
          // ì•„ë°”íƒ€ ëª¨ë“œ ì „ìš© ë¬¸ì¥ë„ ë¯¸ë¦¬ ìºì‹œ
          preloadAvatarPhrases();

          // ì´ˆê¸°í™” ëë‚¬ê³  ëŒ€ê¸° ë¬¸ì¥ì´ ìˆìœ¼ë©´ ì¬ìƒ
          if (pendingText) {
            const textToSpeak = pendingText;
            pendingText = null;
            internalSpeak(textToSpeak);
          }
        } catch (err) {
          console.error("initSpeech() ì¤‘ ì˜¤ë¥˜:", err);
        }
      }

      function initSpeechOnce() {
        if (speechInitPromise) return speechInitPromise;
        speechInitPromise = initSpeech();
        return speechInitPromise;
      }

      function speakText(text) {
        if (!ttsEnabled) return;
        if (!text || text.length === 0) return;
        if (!window.SpeechSDK) {
          console.warn("SpeechSDK is not loaded yet.");
          return;
        }

        // ì•„ì§ ì´ˆê¸°í™”ê°€ ì•ˆ ëìœ¼ë©´ ì¼ë‹¨ íì— ë„£ê³  init
        if (!ttsReady || !speechConfig || !audioConfig || !synthesizer) {
          if (!speechInitPromise) {
            initSpeechOnce();
          }
          pendingText = text;
          console.warn("Speech synthesizer not ready yet, queued:", text);
          return;
        }

        pendingText = text;

        if (isSpeaking) {
          synthesizer.stopSpeakingAsync(
            function () {
              isSpeaking = false;
              const next = pendingText;
              pendingText = null;
              if (next) internalSpeak(next);
            },
            function (err) {
              console.error("TTS stop error:", err);
              isSpeaking = false;
              const next = pendingText;
              pendingText = null;
              if (next) internalSpeak(next);
            }
          );
        } else {
          const next = pendingText;
          pendingText = null;
          internalSpeak(next);
        }
      }

      function internalSpeak(text) {
        if (!text || !synthesizer) return;

        try {
          isSpeaking = true;
          synthesizer.speakTextAsync(
            text,
            function (result) {
              isSpeaking = false;
              if (result.reason === SpeechSDK.ResultReason.Canceled) {
                const cancellation =
                  SpeechSDK.CancellationDetails.fromResult(result);
                console.warn(
                  "TTS canceled:",
                  cancellation.reason,
                  cancellation.errorDetails
                );
              }
            },
            function (err) {
              console.error("TTS error:", err);
              isSpeaking = false;
            }
          );
        } catch (err) {
          console.error("TTS exception:", err);
          isSpeaking = false;
        }
      }

      // ====== ì¹´ìš´íŠ¸ í•œê¸€ ë‹¨ì–´ (1~50 ëŒ€ì‘) ======
      const KOREAN_UNITS = [
        "",
        "í•˜ë‚˜",
        "ë‘˜",
        "ì…‹",
        "ë„·",
        "ë‹¤ì„¯",
        "ì—¬ì„¯",
        "ì¼ê³±",
        "ì—¬ëŸ",
        "ì•„í™‰",
      ];

      const KOREAN_TENS = ["", "ì—´", "ìŠ¤ë¬¼", "ì„œë¥¸", "ë§ˆí”", "ì‰°"];

      function getKoreanCountWord(n) {
        if (n >= 1 && n <= 50) {
          const tens = Math.floor(n / 10);
          const unit = n % 10;

          if (tens === 0) {
            return KOREAN_UNITS[unit];
          }
          if (unit === 0) {
            return KOREAN_TENS[tens];
          }
          return KOREAN_TENS[tens] + KOREAN_UNITS[unit];
        }
        return String(n);
      }

      // ====== ìˆ«ì TTS ìºì‹œ ë° ì¬ìƒ ======
      function preloadSingleNumber(n) {
        if (!ttsReady || !cacheSynthesizer) return;
        if (ttsCache[n]) return;

        const word = getKoreanCountWord(n) + "!";

        cacheSynthesizer.speakTextAsync(
          word,
          function (result) {
            if (
              result.reason ===
              SpeechSDK.ResultReason.SynthesizingAudioCompleted
            ) {
              const audioData = result.audioData;
              if (audioData) {
                try {
                  const blob = new Blob([audioData], { type: "audio/mpeg" });
                  const url = URL.createObjectURL(blob);
                  const audio = new Audio(url);
                  ttsCache[n] = audio;
                } catch (e) {
                  console.warn("Failed to build audio blob for rep", n, e);
                }
              }
            } else if (result.reason === SpeechSDK.ResultReason.Canceled) {
              const cancellation =
                SpeechSDK.CancellationDetails.fromResult(result);
              console.warn(
                "Preload TTS canceled:",
                cancellation.reason,
                cancellation.errorDetails
              );
            }
          },
          function (err) {
            console.error("Preload TTS error:", err);
          }
        );
      }

      function preloadNumberRange(start, end) {
        for (let n = start; n <= end; n++) {
          preloadSingleNumber(n);
        }
      }

      // "5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤." ë¬¸ì¥ì„ ë¯¸ë¦¬ ì˜¤ë””ì˜¤ë¡œ ìºì‹œ
      function preloadCountdownAudio() {
        if (!ttsReady || !cacheSynthesizer) return;
        if (countdownAudio) return;

        const text = "5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤.";

        cacheSynthesizer.speakTextAsync(
          text,
          function (result) {
            if (
              result.reason ===
              SpeechSDK.ResultReason.SynthesizingAudioCompleted
            ) {
              const audioData = result.audioData;
              if (audioData) {
                try {
                  const blob = new Blob([audioData], { type: "audio/mpeg" });
                  const url = URL.createObjectURL(blob);
                  const audio = new Audio(url);
                  countdownAudio = audio;
                } catch (e) {
                  console.warn("Failed to build countdown audio blob", e);
                }
              }
            } else if (result.reason === SpeechSDK.ResultReason.Canceled) {
              const cancellation =
                SpeechSDK.CancellationDetails.fromResult(result);
              console.warn(
                "Preload countdown TTS canceled:",
                cancellation.reason,
                cancellation.errorDetails
              );
            }
          },
          function (err) {
            console.error("Preload countdown TTS error:", err);
          }
        );
      }

      // ì•„ë°”íƒ€ ëª¨ë“œ ì „ìš© ë¬¸ì¥ TTS ìºì‹œ
      function preloadAvatarPhrase(key, text) {
        if (!ttsReady || !cacheSynthesizer) return;
        if (avatarTtsCache[key]) return;

        cacheSynthesizer.speakTextAsync(
          text,
          function (result) {
            if (
              result.reason ===
              SpeechSDK.ResultReason.SynthesizingAudioCompleted
            ) {
              const audioData = result.audioData;
              if (audioData) {
                try {
                  const blob = new Blob([audioData], { type: "audio/mpeg" });
                  const url = URL.createObjectURL(blob);
                  const audio = new Audio(url);
                  avatarTtsCache[key] = audio;
                } catch (e) {
                  console.warn(
                    "Failed to build avatar phrase audio blob for key:",
                    key,
                    e
                  );
                }
              }
            } else if (result.reason === SpeechSDK.ResultReason.Canceled) {
              const cancellation =
                SpeechSDK.CancellationDetails.fromResult(result);
              console.warn(
                "Preload avatar phrase TTS canceled for key:",
                key,
                cancellation.reason,
                cancellation.errorDetails
              );
            }
          },
          function (err) {
            console.error("Preload avatar phrase TTS error for key:", key, err);
          }
        );
      }

      function preloadAvatarPhrases() {
        preloadAvatarPhrase(
          "avatar_start_warning",
          "ì•„ë°”íƒ€ ëª¨ë“œì—ì„œëŠ” ì „ì‹ ì´ í™”ë©´ì— ëª¨ë‘ ë“¤ì–´ì™€ì•¼ í•©ë‹ˆë‹¤. ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë‘ì–´ì£¼ì„¸ìš”."
        );
        preloadAvatarPhrase(
          "avatar_fullbody_ready",
          "ì „ì‹ ì´ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤. ìš´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤."
        );
        preloadAvatarPhrase(
          "avatar_resume",
          "ì „ì‹ ì´ ë‹¤ì‹œ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤. ìš´ë™ì„ ê³„ì†í•©ë‹ˆë‹¤."
        );
        preloadAvatarPhrase(
          "avatar_lost",
          "ì „ì‹ ì´ ì¸ì‹ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë²Œë ¤ì£¼ì‹­ì‹œì˜¤."
        );
      }

      function playAvatarPhrase(key, fallbackText) {
        const audio = avatarTtsCache[key];
        if (audio) {
          try {
            audio.currentTime = 0;
            audio.play();
            return;
          } catch (e) {
            console.warn(
              "Avatar cached audio play error for key:",
              key,
              "fallback to live TTS:",
              e
            );
          }
        }
        // ìºì‹œê°€ ì—†ê±°ë‚˜ ì¬ìƒì— ì‹¤íŒ¨í•˜ë©´ ì¼ë°˜ TTSë¡œ ëŒ€ì²´
        if (fallbackText) {
          speakText(fallbackText);
        }
      }

      function playCountTTS(rep) {
        const cached = ttsCache[rep];
        if (cached) {
          try {
            cached.currentTime = 0;
            cached.play();
          } catch (e) {
            console.warn(
              "Cached audio play error, fallback to live TTS:",
              e
            );
            const word = getKoreanCountWord(rep);
            speakText(word + "!");
          }
        } else {
          const word = getKoreanCountWord(rep);
          speakText(word + "!");
          if (rep >= 1 && rep < 50) {
            preloadSingleNumber(rep + 1);
          }
          return;
        }

        if (rep >= 1 && rep < 50) {
          preloadSingleNumber(rep + 1);
        }
      }

      function handleRepCounted(rep) {
        if (repOverlayEl) {
          if (state.repOverlayTimer) {
            clearTimeout(state.repOverlayTimer);
            state.repOverlayTimer = null;
          }

          repOverlayEl.textContent = rep;
          repOverlayEl.style.opacity = 1;

          state.repOverlayTimer = setTimeout(() => {
            repOverlayEl.style.opacity = 0;
          }, 700);
        }

        playCountTTS(rep);
      }

      const KEY = {
        nose: 0,
        leftEye: 1,
        rightEye: 2,
        leftEar: 3,
        rightEar: 4,
        leftShoulder: 5,
        rightShoulder: 6,
        leftElbow: 7,
        rightElbow: 8,
        leftWrist: 9,
        rightWrist: 10,
        leftHip: 11,
        rightHip: 12,
        leftKnee: 13,
        rightKnee: 14,
        leftAnkle: 15,
        rightAnkle: 16,
      };

      // --------------------------
      // 2. ìš´ë™ ì„¤ì •
      // --------------------------
      const EXERCISES = {
        right_curl: {
          name: "Right Arm Curl",
          type: "ê¸°êµ¬ìš´ë™",
          shortDesc:
            "ì˜¤ë¥¸íŒ”ë¡œ ë¤ë²¨ì„ ë“¤ì–´ ì´ë‘ê·¼ì„ ì§‘ì¤‘ì ìœ¼ë¡œ ë‹¨ë ¨í•©ë‹ˆë‹¤.",
          angleJoints: [KEY.rightShoulder, KEY.rightElbow, KEY.rightWrist],
          thresholds: { up: 155, down: 60 },
          start: {
            hint: "ì˜¤ë¥¸íŒ”ì„ ì˜†ìœ¼ë¡œ ë‚´ë ¤ ì™„ì „íˆ í¸ ìƒíƒœë¡œ ë¤ë²¨ì„ ë“¤ê³  ì„œì„¸ìš”.",
            check(angle) {
              return angle > 150;
            },
          },
          feedback(angle) {
            if (angle > 150) {
              return {
                label: "Ready",
                detail: "íŒ”ì„ ì™„ì „íˆ í¸ ìƒíƒœì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤.",
                good: false,
              };
            }
            if (angle < 70) {
              return {
                label: "Curl",
                detail:
                  "ìˆ˜ì¶• êµ¬ê°„ì…ë‹ˆë‹¤. ìƒì™„ì´ í”ë“¤ë¦¬ì§€ ì•Šê²Œ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                good: true,
              };
            }
            return {
              label: "Moving",
              detail: "ì¢‹ì•„ìš”, ì¼ì •í•œ ì†ë„ë¡œ ì˜¬ë ¸ë‹¤ ë‚´ë¦¬ì„¸ìš”.",
              good: true,
            };
          },
        },
        left_curl: {
          name: "Left Arm Curl",
          type: "ê¸°êµ¬ìš´ë™",
          shortDesc: "ì™¼íŒ” ì´ë‘ê·¼ì„ ê°•í™”í•˜ëŠ” ë‹¨ì¼ ê´€ì ˆ ë¤ë²¨ ìš´ë™ì…ë‹ˆë‹¤.",
          angleJoints: [KEY.leftShoulder, KEY.leftElbow, KEY.leftWrist],
          thresholds: { up: 155, down: 60 },
          start: {
            hint: "ì™¼íŒ”ì„ ì˜†ìœ¼ë¡œ ë‚´ë ¤ ì™„ì „íˆ í¸ ìƒíƒœë¡œ ë¤ë²¨ì„ ë“¤ê³  ì„œì„¸ìš”.",
            check(angle) {
              return angle > 150;
            },
          },
          feedback(angle) {
            if (angle > 150) {
              return {
                label: "Ready",
                detail: "ì™¼íŒ”ì„ ì™„ì „íˆ í¸ ìƒíƒœì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤.",
                good: false,
              };
            }
            if (angle < 70) {
              return {
                label: "Curl",
                detail: "ì™¼íŒ” ìˆ˜ì¶• êµ¬ê°„ì…ë‹ˆë‹¤. ì–´ê¹¨ëŠ” ê³ ì •í•˜ì„¸ìš”.",
                good: true,
              };
            }
            return {
              label: "Moving",
              detail: "ì¢‹ì•„ìš”, ë¦¬ë“¬ì„ ì¼ì •í•˜ê²Œ ìœ ì§€í•˜ì„¸ìš”.",
              good: true,
            };
          },
        },
        squat: {
          name: "Squat",
          type: "ë§¨ëª¸ìš´ë™",
          shortDesc:
            "í•˜ì²´ ì „ë°˜ê³¼ ì½”ì–´ë¥¼ ë™ì‹œì— ì‚¬ìš©í•˜ëŠ” ëŒ€í‘œì ì¸ ë§¨ëª¸ ìŠ¤ì¿¼íŠ¸ì…ë‹ˆë‹¤.",
          angleJoints: [KEY.leftHip, KEY.leftKnee, KEY.leftAnkle],
          thresholds: { up: 165, down: 100 },
          start: {
            hint: "ë°œì„ ì–´ê¹¨ë„ˆë¹„ë¡œ ë²Œë¦¬ê³  ìƒì²´ë¥¼ ì„¸ìš´ ìƒíƒœë¡œ ë˜‘ë°”ë¡œ ì„œì„¸ìš”.",
            check(angle) {
              return angle > 165;
            },
          },
          feedback(angle) {
            if (angle > 170) {
              return {
                label: "Stand",
                detail:
                  "ì™„ì „íˆ ì„œ ìˆëŠ” ìƒíƒœì…ë‹ˆë‹¤. ì¤€ë¹„ê°€ ë˜ë©´ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                good: false,
              };
            }
            if (angle < 90) {
              return {
                label: "Too Low",
                detail: "ë„ˆë¬´ ë‚®ì•„ìš”. í—ˆë¦¬/ë¬´ë¦ ë¶€ë‹´ì— ì£¼ì˜í•˜ì„¸ìš”.",
                good: false,
              };
            }
            if (angle >= 90 && angle <= 110) {
              return {
                label: "Good Depth",
                detail: "ì¢‹ì€ ê¹Šì´ì…ë‹ˆë‹¤. ê°€ìŠ´ì€ í´ê³  ì½”ì–´ë¥¼ ì¡°ì´ì„¸ìš”.",
                good: true,
              };
            }
            return {
              label: "Half Squat",
              detail: "ì¡°ê¸ˆ ë” ë‚´ë ¤ê°€ë©´ ì¢‹ì•„ìš”.",
              good: false,
            };
          },
        },
        lunge_right: {
          name: "Right Lunge",
          type: "ë§¨ëª¸ìš´ë™",
          shortDesc:
            "ì˜¤ë¥¸ë°œì„ ë‚´ë”›ìœ¼ë©° í•˜ì²´ ê· í˜•ê³¼ ê·¼ë ¥ì„ ê¸°ë¥´ëŠ” ëŸ°ì§€ ë™ì‘ì…ë‹ˆë‹¤.",
          angleJoints: [KEY.rightHip, KEY.rightKnee, KEY.rightAnkle],
          thresholds: { up: 165, down: 95 },
          start: {
            hint: "ì˜¤ë¥¸ë°œì„ ì•ìœ¼ë¡œ ë‚´ë”›ê³  ìƒì²´ë¥¼ ì„¸ìš´ ìƒíƒœë¡œ ì¤€ë¹„í•˜ì„¸ìš”.",
            check(angle) {
              return angle > 165;
            },
          },
          feedback(angle) {
            if (angle > 170) {
              return {
                label: "Stand",
                detail:
                  "ìƒì²´ë¥¼ ì„¸ìš°ê³  ì¤‘ì‹¬ì„ ì¡ì€ ë’¤ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                good: false,
              };
            }
            if (angle < 85) {
              return {
                label: "Too Low",
                detail: "ë„ˆë¬´ ê¹ŠìŠµë‹ˆë‹¤. ì•ë¬´ë¦ì´ ë°œëì„ ë„˜ì§€ ì•Šê²Œ!",
                good: false,
              };
            }
            if (angle >= 90 && angle <= 110) {
              return {
                label: "Good Lunge",
                detail: "ì¢‹ì•„ìš”. ìƒì²´ëŠ” ì„¸ìš°ê³  ì½”ì–´ë¥¼ ê¸´ì¥í•˜ì„¸ìš”.",
                good: true,
              };
            }
            return {
              label: "Shallow",
              detail: "ì¡°ê¸ˆ ë” ë‚´ë ¤ê°€ë©´ ì¢‹ì•„ìš”.",
              good: false,
            };
          },
        },
        lunge_left: {
          name: "Left Lunge",
          type: "ë§¨ëª¸ìš´ë™",
          shortDesc:
            "ì™¼ë°œì„ ë‚´ë”›ìœ¼ë©° í•˜ì²´ ê· í˜•ê³¼ ê·¼ë ¥ì„ ê¸°ë¥´ëŠ” ëŸ°ì§€ ë™ì‘ì…ë‹ˆë‹¤.",
          angleJoints: [KEY.leftHip, KEY.leftKnee, KEY.leftAnkle],
          thresholds: { up: 165, down: 95 },
          start: {
            hint: "ì™¼ë°œì„ ì•ìœ¼ë¡œ ë‚´ë”›ê³  ìƒì²´ë¥¼ ì„¸ìš´ ìƒíƒœë¡œ ì¤€ë¹„í•˜ì„¸ìš”.",
            check(angle) {
              return angle > 165;
            },
          },
          feedback(angle) {
            if (angle > 170) {
              return {
                label: "Stand",
                detail:
                  "ìƒì²´ë¥¼ ì„¸ìš°ê³  ì¤‘ì‹¬ì„ ì¡ì€ ë’¤ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                good: false,
              };
            }
            if (angle < 85) {
              return {
                label: "Too Low",
                detail: "ë„ˆë¬´ ê¹ŠìŠµë‹ˆë‹¤. ì•ë¬´ë¦ì´ ë°œëì„ ë„˜ì§€ ì•Šê²Œ!",
                good: false,
              };
            }
            if (angle >= 90 && angle <= 110) {
              return {
                label: "Good Lunge",
                detail: "ì¢‹ì•„ìš”. ìƒì²´ëŠ” ì„¸ìš°ê³  ì½”ì–´ë¥¼ ê¸´ì¥í•˜ì„¸ìš”.",
                good: true,
              };
            }
            return {
              label: "Shallow",
              detail: "ì¡°ê¸ˆ ë” ë‚´ë ¤ê°€ë©´ ì¢‹ì•„ìš”.",
              good: false,
            };
          },
        },
        pushup: {
          name: "Push-up",
          type: "ë§¨ëª¸ìš´ë™",
          shortDesc:
            "ê°€ìŠ´, ì–´ê¹¨, ì‚¼ë‘ê·¼ì„ ë™ì‹œì— ì‚¬ìš©í•˜ëŠ” ëŒ€í‘œì ì¸ í‘¸ì‹œì—… ë™ì‘ì…ë‹ˆë‹¤.",
          angleJoints: [KEY.rightShoulder, KEY.rightElbow, KEY.rightWrist],
          thresholds: { up: 165, down: 80 },
          start: {
            hint: "íŒ”ì„ ì™„ì „íˆ í´ê³  í”Œë­í¬ ìì„¸ë¥¼ ìœ ì§€í•˜ì„¸ìš”.",
            check(angle) {
              return angle > 160;
            },
          },
          feedback(angle) {
            if (angle > 165) {
              return {
                label: "Top",
                detail: "íŒ”ì„ ê³¼í•˜ê²Œ ì ê·¸ì§€ ë§ê³  ì‚´ì§ êµ½íŒ ìƒíƒœë¥¼ ìœ ì§€í•˜ì„¸ìš”.",
                good: true,
              };
            }
            if (angle < 70) {
              return {
                label: "Bottom",
                detail: "ê°€ìŠ´ì´ ë°”ë‹¥ ê°€ê¹Œì´ ì˜¬ ë•Œê¹Œì§€ ë‚´ë ¤ê°€ë˜ í—ˆë¦¬ëŠ” êº¾ì´ì§€ ì•Šê²Œ!",
                good: true,
              };
            }
            return {
              label: "Moving",
              detail: "í˜¸í¡ì„ ìœ ì§€í•˜ë©´ì„œ ì¼ì •í•œ ì†ë„ë¡œ ë‚´ë ¤ê°”ë‹¤ ì˜¬ë¼ì˜¤ì„¸ìš”.",
              good: true,
            };
          },
        },
        shoulder_press: {
          name: "Shoulder Press",
          type: "ê¸°êµ¬ìš´ë™",
          shortDesc:
            "ë¤ë²¨ì„ ìœ„ë¡œ ë°€ì–´ ì˜¬ë¦¬ë©° ì–´ê¹¨ì™€ ìƒì²´ë¥¼ ê°•í™”í•˜ëŠ” ìš´ë™ì…ë‹ˆë‹¤.",
          angleJoints: [KEY.rightShoulder, KEY.rightElbow, KEY.rightWrist],
          thresholds: { up: 160, down: 90 },
          start: {
            hint: "ë¤ë²¨ì„ ê·€ ì˜† ì •ë„ ë†’ì´ë¡œ ë“¤ê³ , íŒ”ê¿ˆì¹˜ê°€ ëª¸ ì•ì— ì˜¤ë„ë¡ ìœ ì§€í•˜ì„¸ìš”.",
            check(angle) {
              return angle >= 90 && angle <= 130;
            },
          },
          feedback(angle) {
            if (angle > 155) {
              return {
                label: "Lockout",
                detail: "íŒ”ì„ ì™„ì „íˆ ì ê·¸ì§€ ë§ê³  ì‚´ì§ êµ½í˜€ ì£¼ì„¸ìš”.",
                good: false,
              };
            }
            if (angle < 90) {
              return {
                label: "Bottom",
                detail: "ì–´ê¹¨ ì•„ë˜ë¡œ ë„ˆë¬´ ë‚´ë¦¬ì§€ ì•Šê²Œ ì£¼ì˜!",
                good: false,
              };
            }
            return {
              label: "Pressing",
              detail: "ì²œì²œíˆ ìœ„ë¡œ ë°€ì–´ ì˜¬ë¦¬ë©° ì½”ì–´ë¥¼ ì¡°ì´ì„¸ìš”.",
              good: true,
            };
          },
        },
      };

      // --------------------------
      // 2.5. ìš´ë™ ì„ íƒê¸° helpers
      // --------------------------
      function updateCurrentExerciseLabel() {
        if (!currentExerciseNameEl) return;
        const ex = EXERCISES[state.currentKey];
        currentExerciseNameEl.textContent = ex ? ex.name : "-";
      }

      function openExercisePicker() {
        if (!exercisePickerOverlay || !exercisePickerPanel) return;
        renderExercisePickerPanel();
        exercisePickerOverlay.style.opacity = 1;
        exercisePickerOverlay.style.pointerEvents = "auto";
      }

      function closeExercisePicker() {
        if (!exercisePickerOverlay) return;
        exercisePickerOverlay.style.opacity = 0;
        exercisePickerOverlay.style.pointerEvents = "none";
      }

      function renderExercisePickerPanel() {
        if (!exercisePickerPanel) return;

        let html = "";
        html += `
            <div class="exercise-picker-header">
              <h2 class="exercise-picker-title">ìš´ë™ ë™ì‘ ì„ íƒ</h2>
              <button id="exercise-picker-close" class="btn secondary" style="font-size:12px; padding:4px 10px;">ë‹«ê¸°</button>
            </div>
            <div class="exercise-picker-grid">
          `;

        for (const key in EXERCISES) {
          if (!Object.prototype.hasOwnProperty.call(EXERCISES, key)) continue;
          const ex = EXERCISES[key];
          html += `
              <div class="exercise-card">
                <h3 class="exercise-card-title">${ex.name}</h3>
                <span class="exercise-type-tag">${ex.type || "ìš´ë™"}</span>
                <p class="exercise-short">${
                  ex.shortDesc || "ì´ ë™ì‘ì„ ì„ íƒí•´ ìì„¸ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤."
                }</p>
                <button class="btn exercise-start-btn" data-ex-key="${key}">ì´ ë™ì‘ìœ¼ë¡œ ì‹œì‘</button>
              </div>
            `;
        }

        html += "</div>";

        exercisePickerPanel.innerHTML = html;

        const closeBtn = document.getElementById("exercise-picker-close");
        if (closeBtn) {
          closeBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            closeExercisePicker();
          });
        }

        const startButtons =
          exercisePickerPanel.querySelectorAll(".exercise-start-btn");
        startButtons.forEach((btn) => {
          btn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const key = btn.getAttribute("data-ex-key");
            if (key && EXERCISES[key]) {
              selectExerciseAndStart(key);
            }
          });
        });
      }

      function selectExerciseAndStart(key) {
        state.currentKey = key;

        resetCounter();
        state.workoutStarted = false;
        state.stage = "up";

        const ex = EXERCISES[key];
        hudExercise.textContent = ex.name;
        updateCurrentExerciseLabel();
        statusLabel.textContent = "Set start position";
        statusDetail.textContent =
          ex.start?.hint || "ì¤€ë¹„ìì„¸ë¥¼ ë§ì¶° ì£¼ì„¸ìš”.";

        speakText(
          ex.name +
            "ë¥¼ ì„ íƒí–ˆìŠµë‹ˆë‹¤. " +
            (ex.start?.hint || "ì¤€ë¹„ìì„¸ë¥¼ ë§ì¶° ì£¼ì„¸ìš”.")
        );

        closeExercisePicker();

        startCountdownAndWorkout();
      }

      const state = {
        currentKey: "right_curl",
        currentMode: "training",
        reps: 0,
        stage: "up",
        lastAngle: 0,
        fps: 0,
        lastFrameTime: performance.now(),
        running: false,
        detector: null,
        animationId: null,
        stream: null,
        showSkeleton: true,
        workoutStarted: false,
        startStableFrames: 0,
        downStableFrames: 0,
        upStableFrames: 0,
        countdownActive: false,
        countdownValue: 0,
        repOverlayTimer: null,
        totalFrames: 0,
        goodFrames: 0,
        isAvatarMode: false,
        // Challenge mode state
        challengeActive: false,
        challengeEndTime: 0,
        challengeDurationMinutes: null,

        // Full-body / avatar control
        fullBodyDetected: false,
        lastFullBodyTime: performance.now(),
        workoutPausedForNoBody: false,
        waitingForFullBodyStart: false,
        countdownTimerId: null,
      };
      // --------------------------
      // Challenge Mode Timer Logic
      // --------------------------
      function startChallenge(minutes) {
        if (!minutes) return;
        state.challengeActive = true;
        state.challengeEndTime = performance.now() + minutes * 60000;
        speakText(minutes + "ë¶„ ë„ì „ ì‹œì‘í•©ë‹ˆë‹¤.");
      }

      function updateChallengeTimer() {
        if (!state.challengeActive) return;
        const now = performance.now();
        const remainingMs = state.challengeEndTime - now;
        const remainingEl = document.getElementById("challenge-remaining");

        if (remainingMs <= 0) {
          if (remainingEl) remainingEl.textContent = "00:00";
          state.challengeActive = false;
          stopWorkout(true);
          speakText("ë„ì „ ì¢…ë£Œ! ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤.");
          return;
        }

        const totalSeconds = Math.ceil(remainingMs / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const text =
          String(minutes).padStart(2, "0") +
          ":" +
          String(seconds).padStart(2, "0");
        if (remainingEl) remainingEl.textContent = text;
      }

      // --------------------------
      // 3. ë„ìš°ë¯¸ & ìŠ¤ì¼ˆë ˆí†¤
      // --------------------------
      function toVec2(kp) {
        return [kp.x, kp.y];
      }

      function angleBetween(a, b, c) {
        const ab = [a[0] - b[0], a[1] - b[1]];
        const cb = [c[0] - b[0], c[1] - b[1]];
        const dot = ab[0] * cb[0] + ab[1] * cb[1];
        const magAB = Math.hypot(ab[0], ab[1]);
        const magCB = Math.hypot(cb[0], cb[1]);
        const cosine = dot / (magAB * magCB + 1e-6);
        const rad = Math.acos(Math.min(Math.max(cosine, -1), 1));
        return (rad * 180) / Math.PI;
      }

      function isFullBodyVisible(keypoints) {
        if (!keypoints || keypoints.length < 17) return false;
        const requiredIndices = [
          KEY.leftShoulder,
          KEY.rightShoulder,
          KEY.leftHip,
          KEY.rightHip,
          KEY.leftKnee,
          KEY.rightKnee,
          KEY.leftAnkle,
          KEY.rightAnkle,
        ];
        for (const idx of requiredIndices) {
          const kp = keypoints[idx];
          if (!kp || kp.score == null || kp.score < 0.4) {
            return false;
          }
        }
        return true;
      }

      function handleFullBodyState(keypoints) {
        // ì´ ë¡œì§ì€ ì•„ë°”íƒ€ ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©
        if (state.currentMode !== "avatar") {
          if (avatarWarningEl) avatarWarningEl.style.display = "none";
          state.fullBodyDetected = false;
          state.workoutPausedForNoBody = false;
          state.waitingForFullBodyStart = false;
          return;
        }

        const now = performance.now();
        const visible = isFullBodyVisible(keypoints);

        if (visible) {
          state.fullBodyDetected = true;
          state.lastFullBodyTime = now;
          if (avatarWarningEl) avatarWarningEl.style.display = "none";

          // ì‹œì‘ ì „ì— ì „ì‹  ì¸ì‹ì„ ê¸°ë‹¤ë¦¬ëŠ” ìƒíƒœì˜€ë‹¤ë©´ â†’ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
          if (state.waitingForFullBodyStart) {
            state.waitingForFullBodyStart = false;
            state.workoutPausedForNoBody = false;
            playAvatarPhrase(
              "avatar_fullbody_ready",
              "ì „ì‹ ì´ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤. ìš´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤."
            );
            startCountdownAndWorkout();
            return;
          }

          // ìš´ë™ ì¤‘ ì¼ì‹œì •ì§€ ìƒíƒœì˜€ë‹¤ë©´ â†’ ì¬ê°œ
          if (
            state.workoutPausedForNoBody &&
            state.workoutStarted &&
            !state.countdownActive
          ) {
            state.workoutPausedForNoBody = false;
            playAvatarPhrase(
              "avatar_resume",
              "ì „ì‹ ì´ ë‹¤ì‹œ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤. ìš´ë™ì„ ê³„ì†í•©ë‹ˆë‹¤."
            );
          }
        } else {
          if (avatarWarningEl) {
            avatarWarningEl.style.display = "flex";
          }

          // ì‹œì‘ ì „ì—ëŠ” ì•ˆë‚´ë§Œ ìœ ì§€
          if (state.waitingForFullBodyStart) {
            state.fullBodyDetected = false;
            return;
          }

          // ìš´ë™ ì¤‘ì´ë¼ë©´ ì¼ì • ì‹œê°„ í›„ ì¼ì‹œì •ì§€
          if (state.workoutStarted && !state.countdownActive) {
            const elapsed = now - state.lastFullBodyTime;
            if (!state.workoutPausedForNoBody && elapsed > 1500) {
              state.workoutPausedForNoBody = true;
              playAvatarPhrase(
                "avatar_lost",
                "ì „ì‹ ì´ ì¸ì‹ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë²Œë ¤ì£¼ì‹­ì‹œì˜¤."
              );
            }
          }

          state.fullBodyDetected = false;
        }
      }

      const SKELETON_CONNECTIONS = [
        [KEY.leftShoulder, KEY.rightShoulder],
        [KEY.leftShoulder, KEY.leftElbow],
        [KEY.leftElbow, KEY.leftWrist],
        [KEY.rightShoulder, KEY.rightElbow],
        [KEY.rightElbow, KEY.rightWrist],
        [KEY.leftShoulder, KEY.leftHip],
        [KEY.rightShoulder, KEY.rightHip],
        [KEY.leftHip, KEY.leftKnee],
        [KEY.leftKnee, KEY.leftAnkle],
        [KEY.rightHip, KEY.rightKnee],
        [KEY.rightKnee, KEY.rightAnkle],
      ];

      function projectToCanvas(kp) {
        const nx = kp.x / videoEl.videoWidth;
        const ny = kp.y / videoEl.videoHeight;
        return {
          x: nx * canvasEl.width,
          y: ny * canvasEl.height,
        };
      }

      function drawSkeleton(keypoints) {
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

        if (!state.showSkeleton) {
          return;
        }

        keypoints.forEach((kp) => {
          if (!kp) return;
          if (kp.score < 0.3) return;

          const { x, y } = projectToCanvas(kp);
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, 2 * Math.PI);
          ctx.fillStyle = "#38bdf8";
          ctx.fill();
        });

        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(56, 189, 248, 0.9)";
        SKELETON_CONNECTIONS.forEach(([i, j]) => {
          const kp1 = keypoints[i];
          const kp2 = keypoints[j];
          if (!kp1 || !kp2) return;
          if (kp1.score < 0.3 || kp2.score < 0.3) return;

          const p1 = projectToCanvas(kp1);
          const p2 = projectToCanvas(kp2);

          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        });
      }

      toggleOverlayBtn.addEventListener("click", () => {
        state.showSkeleton = !state.showSkeleton;
        toggleOverlayBtn.textContent = state.showSkeleton
          ? "í¬ì¦ˆì„  ë„ê¸°"
          : "í¬ì¦ˆì„  ì¼œê¸°";
        if (!state.showSkeleton) {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        }
      });

      function updateHUD(angle, feedback) {
        hudReps.textContent = state.reps;
        hudAngle.textContent = `${Math.round(angle)}Â°`;
        hudFps.textContent = state.fps.toFixed(0);
        statusLabel.textContent = feedback.label;
        statusDetail.textContent = feedback.detail;
        statusDot.classList.remove("good", "bad");
        if (feedback.good) statusDot.classList.add("good");
        else statusDot.classList.add("bad");
      }

      function resetCounter(keepButtonLabel = false) {
        state.reps = 0;
        state.stage = "up";
        state.lastAngle = 0;
        state.workoutStarted = false;
        state.startStableFrames = 0;
        state.downStableFrames = 0;
        state.upStableFrames = 0;
        state.countdownActive = false;

        if (!keepButtonLabel && startWorkoutBtn) {
          startWorkoutBtn.textContent = "ìš´ë™ ì‹œì‘";
        }

        if (state.repOverlayTimer) {
          clearTimeout(state.repOverlayTimer);
          state.repOverlayTimer = null;
        }
        if (repOverlayEl) {
          repOverlayEl.style.opacity = 0;
          repOverlayEl.textContent = "";
        }

        state.totalFrames = 0;
        state.goodFrames = 0;

        if (summaryOverlayEl) {
          summaryOverlayEl.style.opacity = 0;
          summaryOverlayEl.style.pointerEvents = "none";
        }

        statusLabel.textContent = "-";
        statusDetail.textContent = "";
        statusDot.classList.remove("good", "bad");

        hudReps.textContent = "0";
        hudAngle.textContent = "0Â°";
      }

      // --------------------------
      // 4. ì¹´ìš´íŒ… & MoveNet
      // --------------------------
      function updateRepsForExercise(ex, angle) {
        const { up, down } = ex.thresholds;

        if (angle <= down) {
          state.downStableFrames += 1;
          state.upStableFrames = 0;
        } else if (angle >= up) {
          state.upStableFrames += 1;
          state.downStableFrames = 0;
        } else {
          state.downStableFrames = 0;
          state.upStableFrames = 0;
        }

        if (state.stage === "up" && state.downStableFrames >= 2) {
          state.stage = "down";
          return;
        }

        if (state.stage === "down" && state.upStableFrames >= 2) {
          state.stage = "up";
          state.reps += 1;
          if (state.reps > 0) {
            handleRepCounted(state.reps);
          }

          if (
            state.currentMode !== "challenge" &&
            state.reps >= 30 &&
            state.workoutStarted
          ) {
            stopWorkout(true);
          }
        }
      }

      async function createDetector() {
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
        };
        return poseDetection.createDetector(model, detectorConfig);
      }

      // --------------------------
      // 5. ë©”ì¸ ë£¨í”„
      // --------------------------
      async function renderLoop() {
        if (!state.detector || !state.running) return;

        const now = performance.now();
        const dt = now - state.lastFrameTime;
        state.lastFrameTime = now;
        state.fps = 1000 / dt;

        const poses = await state.detector.estimatePoses(videoEl, {
          maxPoses: 1,
          flipHorizontal: true,
        });

        if (poses.length > 0) {
          const kp = poses[0].keypoints;

          // ì•„ë°”íƒ€ ëª¨ë“œì—ì„œ ì „ì‹  ì¸ì‹ ìƒíƒœ ì—…ë°ì´íŠ¸
          handleFullBodyState(kp);

          const ex = EXERCISES[state.currentKey];
          const [ia, ib, ic] = ex.angleJoints;

          const a = toVec2(kp[ia]);
          const b = toVec2(kp[ib]);
          const c = toVec2(kp[ic]);

          const angle = angleBetween(a, b, c);
          state.lastAngle = angle;

          // ì•„ë°”íƒ€ ëª¨ë“œì—ì„œëŠ” ì „ì‹ ì´ ì¸ì‹ëœ ê²½ìš°ì—ë§Œ ì•„ë°”íƒ€ë¥¼ ì›€ì§ì„
          if (state.isAvatarMode && state.fullBodyDetected) {
            updateAvatarFromPose(kp);
          }

          if (!state.workoutStarted) {
            let ok = false;
            if (ex.start && typeof ex.start.check === "function") {
              ok = ex.start.check(angle, kp);
            } else {
              ok = angle > ex.thresholds.up - 5;
            }

            if (ok) state.startStableFrames += 1;
            else state.startStableFrames = 0;

            drawSkeleton(kp);
            const fb = {
              label: ok ? "Hold start position" : "Set start position",
              detail:
                ex.start?.hint ||
                "ì¤€ë¹„ìì„¸ë¥¼ ë§ì¶° ì£¼ì„¸ìš”. (ì •ë©´ì„ ë³´ê³  í™”ë©´ ì¤‘ì•™ì— ì„œì„¸ìš”.)",
              good: ok,
            };
            updateHUD(angle, fb);
          } else if (state.currentMode === "avatar" && state.workoutPausedForNoBody) {
            // ì•„ë°”íƒ€ ëª¨ë“œì—ì„œ ì „ì‹  ì¸ì‹ì´ ì•ˆ ë˜ë©´ ìš´ë™ì„ ì¼ì‹œ ì¤‘ì§€í•˜ê³  ê²½ê³  í‘œì‹œ
            const fb = {
              label: "ì „ì‹  ì¸ì‹ ì•ˆ ë¨",
              detail: "ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë‘ì–´ ì „ì‹ ì´ ëª¨ë‘ ë³´ì´ê²Œ ì„œì£¼ì„¸ìš”.",
              good: false,
            };
            drawSkeleton(kp);
            updateHUD(angle, fb);
          } else {
            updateRepsForExercise(ex, angle);
            const fb = ex.feedback(angle);

            state.totalFrames += 1;
            if (fb.good) {
              state.goodFrames += 1;
            }

            drawSkeleton(kp);
            updateHUD(angle, fb);
          }
        } else {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
          statusLabel.textContent = "No pose";
          statusDetail.textContent =
            "ì‚¬ëŒì´ í™”ë©´ ì•ˆì— ìˆë„ë¡ ìœ„ì¹˜ë¥¼ ì¡°ì •í•˜ì„¸ìš”.";
          statusDot.classList.remove("good", "bad");

          // í¬ì¦ˆê°€ ì „í˜€ ì¸ì‹ë˜ì§€ ì•Šì„ ë•Œë„ ì „ì‹  ì¸ì‹ ìƒíƒœ ì²˜ë¦¬
          handleFullBodyState(null);
        }

        updateChallengeTimer();
        state.animationId = requestAnimationFrame(renderLoop);
      }

      // --------------------------
      // 6. ì¹´ë©”ë¼ ì‹œì‘/ì •ì§€ (ê³µìœ )
      // --------------------------
      async function startCamera() {
        if (state.running) return;
        try {
          toggleCameraBtn.disabled = true;
          toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...";
          if (avatarCameraBtn) {
            avatarCameraBtn.disabled = true;
            avatarCameraBtn.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...";
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
            audio: false,
          });
          state.stream = stream;
          videoEl.srcObject = stream;

          await videoEl.play();

          canvasEl.width = videoEl.videoWidth;
          canvasEl.height = videoEl.videoHeight;

          if (!state.detector) {
            state.detector = await createDetector();
          }

          state.running = true;
          state.lastFrameTime = performance.now();
          toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì •ì§€";
          toggleCameraBtn.disabled = false;
          if (avatarCameraBtn) {
            avatarCameraBtn.textContent = "ì¹´ë©”ë¼ ì •ì§€";
            avatarCameraBtn.disabled = false;
          }
          renderLoop();

          speakText(
            "ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. í™”ë©´ ì¤‘ì•™ì— ì„œì„œ ìì„¸ë¥¼ ë§ì¶° ì£¼ì„¸ìš”."
          );
        } catch (err) {
          console.error(err);
          alert("ì¹´ë©”ë¼ ì ‘ê·¼ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.");
          toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì‹œì‘";
          toggleCameraBtn.disabled = false;
          if (avatarCameraBtn) {
            avatarCameraBtn.textContent = "ì¹´ë©”ë¼ ì‹œì‘";
            avatarCameraBtn.disabled = false;
          }
        }
      }

      function stopCamera() {
        state.running = false;
        if (state.animationId) cancelAnimationFrame(state.animationId);
        if (state.stream) {
          state.stream.getTracks().forEach((t) => t.stop());
          state.stream = null;
        }
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì‹œì‘";
        toggleCameraBtn.disabled = false;
        if (avatarCameraBtn) {
          avatarCameraBtn.textContent = "ì¹´ë©”ë¼ ì‹œì‘";
          avatarCameraBtn.disabled = false;
        }
      }

      // --------------------------
      // 6.5. ì¹´ìš´íŠ¸ë‹¤ìš´ & ìš´ë™ ì‹œì‘
      // --------------------------
      function startCountdownAndWorkout() {
        if (!state.running || state.countdownActive) return;

        // ê¸°ì¡´ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ë‚¨ì•„ ìˆìœ¼ë©´ ì •ë¦¬
        if (state.countdownTimerId) {
          clearInterval(state.countdownTimerId);
          state.countdownTimerId = null;
        }

        // ë„ì „ ëª¨ë“œì—ì„œëŠ” ë¨¼ì € ì‹œê°„ ì„ íƒ í•„ìš”
        if (state.currentMode === "challenge" && !state.challengeDurationMinutes) {
          statusLabel.textContent = "ì‹œê°„ ì„ íƒ í•„ìš”";
          statusDetail.textContent =
            "ë„ì „ ëª¨ë“œì—ì„œëŠ” ë¨¼ì € ë„ì „ ì‹œê°„ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.";
          speakText("ë„ì „ ì‹œê°„ì„ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”.");
          return;
        }

        if (startWorkoutBtn) {
          startWorkoutBtn.textContent =
            state.currentMode === "challenge" ? "ë„ì „ ì¤‘ì§€" : "ìš´ë™ ì •ì§€";
        }

        state.countdownActive = true;
        state.countdownValue = 5;

        resetCounter(true);
        statusLabel.textContent = "ì‹œì‘ ì¤€ë¹„";
        statusDetail.textContent = "5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤.";

        countdownEl.textContent = state.countdownValue;
        countdownEl.style.opacity = 1;

        if (countdownAudio) {
          try {
            countdownAudio.currentTime = 0;
            countdownAudio.play();
          } catch (e) {
            console.warn(
              "Countdown cached audio play error, fallback to TTS:",
              e
            );
            speakText("5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤.");
          }
        } else {
          speakText("5ì´ˆ í›„ì— ì‹œì‘í•©ë‹ˆë‹¤.");
          if (ttsReady) {
            preloadCountdownAudio();
          }
        }

        state.countdownTimerId = setInterval(() => {
          state.countdownValue -= 1;
          if (state.countdownValue > 0) {
            countdownEl.textContent = state.countdownValue;
          } else {
            clearInterval(state.countdownTimerId);
            state.countdownTimerId = null;
            countdownEl.style.opacity = 0;
            state.countdownActive = false;

            state.workoutStarted = true;
            statusLabel.textContent =
              state.currentMode === "challenge" ? "ë„ì „ ì‹œì‘" : "ìš´ë™ ì‹œì‘";
            statusDetail.textContent = "";
            speakText("ì‹œì‘í•©ë‹ˆë‹¤.");

            // ë„ì „ ëª¨ë“œë©´ íƒ€ì´ë¨¸ ì‹œì‘
            if (state.currentMode === "challenge") {
              startChallenge(state.challengeDurationMinutes);
            } else {
              state.challengeActive = false;
              const remainingEl = document.getElementById("challenge-remaining");
              if (remainingEl) remainingEl.textContent = "-";
            }
          }
        }, 1000);
      }

      function stopWorkout(auto = false) {
        // ì§„í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ì´ ìˆìœ¼ë©´ ì •ë¦¬
        if (state.countdownTimerId) {
          clearInterval(state.countdownTimerId);
          state.countdownTimerId = null;
        }
        state.challengeActive = false;
        state.challengeDurationMinutes = state.currentMode === "challenge"
          ? state.challengeDurationMinutes
          : null;
        const remainingEl = document.getElementById("challenge-remaining");
        if (remainingEl) {
          remainingEl.textContent = "-";
        }

        state.workoutStarted = false;
        state.countdownActive = false;
        state.startStableFrames = 0;
        // ì•„ë°”íƒ€ ëª¨ë“œ ì „ì‹  ì¸ì‹/ì¼ì‹œì •ì§€ ìƒíƒœë„ ì´ˆê¸°í™”
        state.waitingForFullBodyStart = false;
        state.workoutPausedForNoBody = false;
        state.fullBodyDetected = false;

        if (countdownEl) {
          countdownEl.style.opacity = 0;
        }

        if (startWorkoutBtn) {
          startWorkoutBtn.textContent = "ìš´ë™ ì‹œì‘";
        }

        if (auto) {
          statusLabel.textContent = "ëª©í‘œ ì™„ë£Œ";
          statusDetail.textContent = "30íšŒë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤. ìš”ì•½ì„ í™•ì¸í•˜ì„¸ìš”.";
        } else {
          statusLabel.textContent = "ìš´ë™ ì •ì§€";
          statusDetail.textContent =
            "ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ 'ìš´ë™ ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.";
        }

        showSummaryReport();

        if (state.reps > 0) {
          const msg = `ì´ ${state.reps}íšŒ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤. ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤.`;
          speakText(msg);
        }
      }

      // --------------------------
      // 7. ì´ë²¤íŠ¸ ë°”ì¸ë”©
      // --------------------------
      toggleCameraBtn.addEventListener("click", () => {
        if (!state.running) startCamera();
        else stopCamera();
      });

      if (avatarCameraBtn) {
        avatarCameraBtn.addEventListener("click", () => {
          if (!state.running) startCamera();
          else stopCamera();
        });
      }

      resetBtn.addEventListener("click", () => {
        resetCounter();
      });

      startWorkoutBtn.addEventListener("click", () => {
        // ì´ë¯¸ ì–´ë–¤ í˜•íƒœë¡œë“  "ì§„í–‰ ì¤‘" (ì¹´ìš´íŠ¸ë‹¤ìš´, ì‹¤ì œ ìš´ë™, ì „ì‹  ëŒ€ê¸°, ì „ì‹  ë¯¸ì¸ì‹ ì¼ì‹œì •ì§€)ì´ë©´ â†’ ì •ì§€ ì²˜ë¦¬
        if (
          state.workoutStarted ||
          state.countdownActive ||
          state.waitingForFullBodyStart ||
          state.workoutPausedForNoBody
        ) {
          stopWorkout(false);
          return;
        }

        // ì—¬ê¸°ê¹Œì§€ ì˜¤ë©´ "ì™„ì „íˆ ë©ˆì¶˜ ìƒíƒœ"ì—ì„œ ìƒˆë¡œ ì‹œì‘í•˜ëŠ” ê²ƒ

        // ì•„ë°”íƒ€ ëª¨ë“œ: ë¨¼ì € ì „ì‹  ì¸ì‹ì„ ê°•ì œí•˜ê³ , ì „ì‹ ì´ ì¡íˆë©´ 5ì´ˆ ì¹´ìš´íŠ¸ í›„ ì‹œì‘
        if (state.currentMode === "avatar") {
          state.waitingForFullBodyStart = true;
          state.workoutPausedForNoBody = false;
          state.fullBodyDetected = false;

          statusLabel.textContent = "ì „ì‹  ì¸ì‹ ëŒ€ê¸°";
          statusDetail.textContent =
            "ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë‘ì–´ ì „ì‹ ì´ ëª¨ë‘ ë³´ì´ê²Œ ì„œì£¼ì„¸ìš”.";

          if (avatarWarningEl) {
            avatarWarningEl.style.display = "flex";
          }

          if (startWorkoutBtn) {
            // ì•„ë°”íƒ€ ëª¨ë“œì—ì„œë„ ì‚¬ìš©ìê°€ 'ì‹œì‘'ì„ ëˆŒë €ë‹¤ëŠ” í”¼ë“œë°±ì„ ì£¼ê¸° ìœ„í•´ ì¦‰ì‹œ 'ìš´ë™ ì •ì§€'ë¡œ ë³€ê²½
            startWorkoutBtn.textContent = "ìš´ë™ ì •ì§€";
          }

          // ì „ì‹  ì¸ì‹ ì•ˆë‚´ TTS (ë¯¸ë¦¬ ìºì‹œëœ ì˜¤ë””ì˜¤ ìš°ì„  ì‚¬ìš©)
          playAvatarPhrase(
            "avatar_start_warning",
            "ì•„ë°”íƒ€ ëª¨ë“œì—ì„œëŠ” ì „ì‹ ì´ í™”ë©´ì— ëª¨ë‘ ë“¤ì–´ì™€ì•¼ í•©ë‹ˆë‹¤. ì¹´ë©”ë¼ì™€ ì¶©ë¶„í•œ ê±°ë¦¬ë¥¼ ë‘ì–´ì£¼ì„¸ìš”."
          );

          // ì‹¤ì œ ì¹´ìš´íŠ¸ë‹¤ìš´ì€ handleFullBodyStateì—ì„œ ì „ì‹  ì¸ì‹ í™•ì¸ í›„ startCountdownAndWorkout() í˜¸ì¶œ
          return;
        }

        // ì¼ë°˜ íŠ¸ë ˆì´ë‹ / ë„ì „ ëª¨ë“œ: ê¸°ì¡´ ë¡œì§ ìœ ì§€ (ì¦‰ì‹œ 5ì´ˆ ì¹´ìš´íŠ¸ í›„ ì‹œì‘)
        startCountdownAndWorkout();
      });

      if (openExercisePickerBtn) {
        openExercisePickerBtn.addEventListener("click", () => {
          openExercisePicker();
        });
      }

      if (exercisePickerOverlay) {
        exercisePickerOverlay.addEventListener("click", (ev) => {
          if (ev.target === exercisePickerOverlay) {
            closeExercisePicker();
          }
        });
      }

      hudExercise.textContent = EXERCISES[state.currentKey].name;
      updateCurrentExerciseLabel();

      initSpeechOnce();

      // --------------------------
      // 8. ìš”ì•½ ì˜¤ë²„ë ˆì´
      // --------------------------
      function showSummaryReport() {
        if (!summaryOverlayEl) return;

        const total = state.totalFrames || 0;
        const good = state.goodFrames || 0;
        const ratio = total > 0 ? good / total : 0;

        let qualityText = "ë¶„ì„í•  ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.";
        if (total > 30) {
          if (ratio >= 0.7) {
            qualityText =
              "ìì„¸ ì•ˆì •ë„: ì¢‹ìŒ (ì¢‹ì€ ìì„¸ ë¹„ìœ¨ ì•½ " +
              Math.round(ratio * 100) +
              "%)";
          } else if (ratio >= 0.4) {
            qualityText =
              "ìì„¸ ì•ˆì •ë„: ë³´í†µ (ì¢‹ì€ ìì„¸ ë¹„ìœ¨ ì•½ " +
              Math.round(ratio * 100) +
              "%)";
          } else {
            qualityText =
              "ìì„¸ ì•ˆì •ë„: ê°œì„  í•„ìš” (ì¢‹ì€ ìì„¸ ë¹„ìœ¨ ì•½ " +
              Math.round(ratio * 100) +
              "%)";
          }
        }

        const ex = EXERCISES[state.currentKey];

        summaryOverlayEl.innerHTML = `
            <div style="max-width:420px; padding:24px 28px; border-radius:18px; background:rgba(15,23,42,0.98); border:1px solid rgba(148,163,184,0.4); box-shadow:0 24px 60px rgba(0,0,0,0.8);">
              <h2 style="margin:0 0 12px; font-size:20px; font-weight:700;">ìš´ë™ ìš”ì•½</h2>
              <p style="margin:0 0 8px; font-size:14px; color:#9ca3af;">${ex.name}</p>
              <p style="margin:0 0 4px; font-size:16px;">ì´ íšŸìˆ˜: <strong>${state.reps}</strong>íšŒ</p>
              <p style="margin:0 0 12px; font-size:14px; color:#e5e7eb;">${qualityText}</p>
              <p style="margin:0 0 16px; font-size:13px; color:#9ca3af;">ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ í™”ë©´ì„ í´ë¦­í•˜ê±°ë‚˜ ì•„ë˜ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</p>
              <button id="summary-close-btn" class="btn secondary" style="padding:6px 14px; font-size:13px;">ë‹«ê¸°</button>
            </div>
          `;

        summaryOverlayEl.style.opacity = 1;
        summaryOverlayEl.style.pointerEvents = "auto";

        const closeBtn = document.getElementById("summary-close-btn");
        if (closeBtn) {
          closeBtn.addEventListener("click", function (ev) {
            ev.stopPropagation();
            hideSummaryOverlay();
          });
        }
      }

      function hideSummaryOverlay() {
        if (!summaryOverlayEl) return;
        summaryOverlayEl.style.opacity = 0;
        summaryOverlayEl.style.pointerEvents = "none";
      }

      if (summaryOverlayEl) {
        summaryOverlayEl.addEventListener("click", () => {
          hideSummaryOverlay();
        });
      }

      // ===========================
      // ë©”ë‰´ & ì•„ë°”íƒ€ ëª¨ë“œ
      // ===========================
      const trainingView = document.getElementById("training-view");
      const avatarView = document.getElementById("avatar-view");
      const challengeView = document.getElementById("challenge-view");
      const devView = document.getElementById("dev-view");

      const menuTrainingBtn = document.getElementById("menu-training");
      const menuAvatarBtn = document.getElementById("menu-avatar");
      const menuChallengeBtn = document.getElementById("menu-challenge");
      const menuDevBtn = document.getElementById("menu-dev");

      const allViews = [trainingView, avatarView, challengeView, devView];

      function showView(targetView) {
        // ê³µìš© ì¹´ë©”ë¼/í›ˆë ¨ ì˜ì—­ì€ í•­ìƒ í‘œì‹œ
        if (trainingView) {
          trainingView.style.display = "block";
        }

        // ë‚˜ë¨¸ì§€ ë³´ì¡° ë·°ë§Œ ì„ íƒì ìœ¼ë¡œ í‘œì‹œ
        [avatarView, challengeView, devView].forEach((v) => {
          if (!v) return;
          v.style.display = v === targetView ? "block" : "none";
        });
      }

      const menuButtons = document.querySelectorAll("#top-menu .btn.secondary");
      function setActiveMenu(btn) {
        menuButtons.forEach((b) => {
          if (!b) return;
          b.classList.toggle("active", b === btn);
        });
      }

      menuTrainingBtn.addEventListener("click", () => {
        showView(trainingView);
        state.currentMode = "training";
        setActiveMenu(menuTrainingBtn);
        if (avatarStyleWrapper) {
          avatarStyleWrapper.style.display = "none";
        }
        state.isAvatarMode = false;
        state.showSkeleton = true;
        if (toggleOverlayBtn) {
          toggleOverlayBtn.style.display = "inline-flex";
          toggleOverlayBtn.textContent = "í¬ì¦ˆì„  ë„ê¸°";
        }
        const avatarContainer = document.getElementById("avatar-container");
        if (avatarContainer) {
          avatarContainer.style.display = "none";
        }
        const cameraLayer = document.getElementById("camera-layer");
        if (cameraLayer) {
          cameraLayer.style.display = "block";
        }
        if (state.running) {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        }
        if (startWorkoutBtn) startWorkoutBtn.textContent = "ìš´ë™ ì‹œì‘";
        state.challengeActive = false;
        state.challengeDurationMinutes = null;
        const remainingElT = document.getElementById("challenge-remaining");
        if (remainingElT) remainingElT.textContent = "-";
      });

      menuAvatarBtn.addEventListener("click", () => {
        showView(avatarView);
        state.currentMode = "avatar";
        setActiveMenu(menuAvatarBtn);
        if (avatarStyleWrapper) {
          avatarStyleWrapper.style.display = "block";
        }
        state.isAvatarMode = true;
        state.showSkeleton = false;
        if (toggleOverlayBtn) {
          // ì•„ë°”íƒ€ ëª¨ë“œì—ì„œëŠ” í¬ì¦ˆì„  í† ê¸€ ë²„íŠ¼ ìˆ¨ê¹€
          toggleOverlayBtn.style.display = "none";
        }
        const avatarContainer = document.getElementById("avatar-container");
        if (avatarContainer) {
          avatarContainer.style.display = "block";
          document.getElementById("camera-layer").style.display = "none";
          avatarContainer.style.borderRadius = "18px";
          avatarContainer.style.inset = "0";
          avatarContainer.style.width = "100%";
          avatarContainer.style.height = "100%";
        }
        if (avatarWarningEl) {
          avatarWarningEl.style.display = "flex";
        }
        state.fullBodyDetected = false;
        state.workoutPausedForNoBody = false;
        state.waitingForFullBodyStart = false;
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        if (startWorkoutBtn) startWorkoutBtn.textContent = "ìš´ë™ ì‹œì‘";
        state.challengeActive = false;
        state.challengeDurationMinutes = null;
        const remainingElA = document.getElementById("challenge-remaining");
        if (remainingElA) remainingElA.textContent = "-";
        if (!window.avatarInitialized) {
          initAvatarMode();
          window.avatarInitialized = true;
        }
      });

      menuChallengeBtn.addEventListener("click", () => {
        showView(challengeView);
        state.currentMode = "challenge";
        setActiveMenu(menuChallengeBtn);
        if (avatarStyleWrapper) {
          avatarStyleWrapper.style.display = "none";
        }
        state.isAvatarMode = false;
        if (toggleOverlayBtn) {
          toggleOverlayBtn.style.display = "inline-flex";
          toggleOverlayBtn.textContent = "í¬ì¦ˆì„  ë„ê¸°";
        }
  // Hide avatar container if visible
        // Hide avatar container if visible
        const avatarContainer = document.getElementById("avatar-container");
        if (avatarContainer) {
          avatarContainer.style.display = "none";
        }
        // Show camera layer again
        const cameraLayer = document.getElementById("camera-layer");
        if (cameraLayer) {
          cameraLayer.style.display = "block";
        }
        if (startWorkoutBtn) startWorkoutBtn.textContent = "ë„ì „ ì‹œì‘";
        state.challengeActive = false;
        const remainingElC = document.getElementById("challenge-remaining");
        if (remainingElC) remainingElC.textContent = "-";
      });

      menuDevBtn.addEventListener("click", () => {
        showView(devView);
        // ê°œë°œì ë„êµ¬ì—ì„œëŠ” ìš´ë™ í¬ì¦ˆ ì¸ì‹ ì˜ì—­(íŠ¸ë ˆì´ë‹ ë·°)ì„ ìˆ¨ê¹€
        if (trainingView) {
          trainingView.style.display = "none";
        }
        state.currentMode = "dev";
        setActiveMenu(menuDevBtn);
        if (avatarStyleWrapper) {
          avatarStyleWrapper.style.display = "none";
        }
        state.isAvatarMode = false;
        if (startWorkoutBtn) startWorkoutBtn.textContent = "ìš´ë™ ì‹œì‘";
        state.challengeActive = false;
        state.challengeDurationMinutes = null;
        const remainingElD = document.getElementById("challenge-remaining");
        if (remainingElD) remainingElD.textContent = "-";
      });
      // ===========================
      // Challenge timer buttons event binding
      // ===========================
      const challengeTimerButtons = document.querySelectorAll(".challenge-timer");
      let selectedChallengeButton = null;
      challengeTimerButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const mins = parseInt(btn.dataset.minutes, 10);
          state.challengeDurationMinutes = mins;
          state.challengeActive = false;

          if (selectedChallengeButton) {
            selectedChallengeButton.classList.remove("active");
          }
          btn.classList.add("active");
          selectedChallengeButton = btn;

          const remainingEl = document.getElementById("challenge-remaining");
          if (remainingEl) {
            remainingEl.textContent =
              String(mins).padStart(2, "0") + ":00";
          }

          statusLabel.textContent = "ë„ì „ ì‹œê°„ ì„ íƒë¨";
          statusDetail.textContent =
            mins + "ë¶„ ë™ì•ˆ ìˆ˜í–‰ ê°€ëŠ¥í•œ íšŸìˆ˜ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.";
          speakText(mins + "ë¶„ ë„ì „ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.");
        });
      });

      showView(trainingView);
      setActiveMenu(menuTrainingBtn);

      // ===========================
      // ì•„ë°”íƒ€ ì´ˆê¸°í™” & ì—…ë°ì´íŠ¸
      // ===========================
      function initAvatarMode() {
        const container = document.getElementById("avatar-container");
        if (!container) return;

        avatarScene = new THREE.Scene();

        const aspect = container.clientWidth / container.clientHeight || 1;
        avatarCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        avatarCamera.position.z = 800;
        avatarCamera.position.y = 500;

        avatarRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        avatarRenderer.setSize(container.clientWidth, container.clientHeight);
        avatarRenderer.setPixelRatio(window.devicePixelRatio || 1);
        container.appendChild(avatarRenderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        avatarScene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        avatarScene.add(directionalLight);

        loadAvatarModel("basic");
        animateAvatar();
      }

      function animateAvatar() {
        requestAnimationFrame(animateAvatar);
        if (avatarRenderer && avatarScene && avatarCamera) {
          avatarRenderer.render(avatarScene, avatarCamera);
        }
      }

      function loadAvatarModel(name) {
        const url = AVATAR_MODELS[name] || AVATAR_MODELS.basic;
        const loader = new GLTFLoader();

        if (avatarModel && avatarScene) {
          avatarScene.remove(avatarModel);
          avatarModel = null;
          avatarBoneMap = null;
        }

        loader.load(
          url,
          (gltf) => {
            avatarModel = gltf.scene;

            const boneMap = {};
            avatarModel.traverse((obj) => {
              if (obj.isBone) {
                boneMap[obj.name] = obj;
              }
            });
            avatarBoneMap = boneMap;
            console.log("Avatar bone map:", avatarBoneMap);

            // ì›ë³¸ ë°”ìš´ë”©ë°•ìŠ¤ë¡œ í¬ê¸°/ì¤‘ì‹¬ ê³„ì‚°
            const box = new THREE.Box3().setFromObject(avatarModel);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            // ìˆ˜í‰(x, z)ìœ¼ë¡œëŠ” ì¤‘ì•™ ì •ë ¬, ë°œë°”ë‹¥ì´ y=0 ê·¼ì²˜ì— ì˜¤ë„ë¡ ì´ë™
            avatarModel.position.x -= center.x;
            avatarModel.position.z -= center.z;
            avatarModel.position.y -= box.min.y;

            // ì•„ë°”íƒ€ ì „ì²´ í‚¤ë¥¼ ì¼ì •í•˜ê²Œ ë§ì¶”ê¸° ìœ„í•œ ìŠ¤ì¼€ì¼ (ëŒ€ëµ 1.7m ì •ë„)
            const desiredHeight = 1.7;
            const scale = desiredHeight / (size.y || 1);
            if (isFinite(scale) && scale > 0) {
              avatarModel.scale.set(scale, scale, scale);
            } else {
              avatarModel.scale.set(1, 1, 1);
            }

            avatarScene.add(avatarModel);

            // ì¹´ë©”ë¼ë¥¼ ì•„ë°”íƒ€ ì „ì²´ê°€ í™”ë©´ ì•ˆì— ì—¬ìœ  ìˆê²Œ ë“¤ì–´ì˜¤ë„ë¡ ë°°ì¹˜
            if (avatarCamera) {
              const newBox = new THREE.Box3().setFromObject(avatarModel);
              const newSize = newBox.getSize(new THREE.Vector3());
              const newCenter = newBox.getCenter(new THREE.Vector3());

              // ì„¸ë¡œ/ê°€ë¡œ í¬ê¸° ì¤‘ ë” í° ìª½ì„ ê¸°ì¤€ìœ¼ë¡œ ê±°ë¦¬ ê³„ì‚°
              const maxDim = Math.max(newSize.y, newSize.x);
              const fovRad = (avatarCamera.fov * Math.PI) / 180;

              // í™”ë©´ì— ê½‰ ì°¨ê²Œ ë³´ì´ëŠ” ê±°ë¦¬ë³´ë‹¤ ë” ë©€ë¦¬ ë–¨ì–´ëœ¨ë ¤ì„œ ì „ì²´ê°€ ë³´ì´ë„ë¡ í•¨
              let distance = (maxDim / 2) / Math.tan(fovRad / 2);
              distance *= 10.0; // ê¸°ì¡´ë³´ë‹¤ ë” ë©€ë¦¬ (ì¤Œ ì•„ì›ƒ)

              // ì¹´ë©”ë¼ë¥¼ ìºë¦­í„° ì •ì¤‘ì•™ ì•½ê°„ ìœ„ìª½ì„ ë°”ë¼ë³´ë„ë¡ ì„¤ì •
              const targetY = newCenter.y + newSize.y * 0.05;
              avatarCamera.position.set(newCenter.x, targetY + newSize.y * 2, distance);
              avatarCamera.lookAt(newCenter.x, targetY + newSize.y * 2, newCenter.z);
            }
          },
          undefined,
          (error) => {
            console.error("Avatar GLB ë¡œë”© ì‹¤íŒ¨:", error);
          }
        );
      }

      function updateAvatarFromPose(keypoints) {
        if (!avatarModel || !keypoints || keypoints.length < 17) return;

        const MIN_CONFIDENCE = 0.3;

        function isConfident(kp) {
          return kp && kp.score >= MIN_CONFIDENCE;
        }

        function findBone(name) {
          if (!avatarModel) return null;
          if (avatarBoneMap && avatarBoneMap[name]) {
            return avatarBoneMap[name];
          }
          let found = null;
          avatarModel.traverse((child) => {
            if (
              child.name === name ||
              child.name.toLowerCase() === name.toLowerCase()
            ) {
              found = child;
            }
          });
          if (found && avatarBoneMap) {
            avatarBoneMap[name] = found;
          }
          return found;
        }

        function computeDirection(from, to) {
          if (!isConfident(from) || !isConfident(to)) return null;
          const dx = to.x - from.x;
          const dy = -(to.y - from.y);
          const dz = 0;
          const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
          if (len < 0.001) return null;
          return { x: dx / len, y: dy / len, z: dz / len };
        }

        function rotateBone(boneName, dir) {
          if (!dir) return;
          const bone = findBone(boneName);
          if (!bone) return;

          const targetPos = new THREE.Vector3(
            bone.position.x + dir.x,
            bone.position.y + dir.y,
            bone.position.z + dir.z
          );
          bone.lookAt(targetPos);
        }

        const rShoulder = keypoints[6];
        const rElbow = keypoints[8];
        const rWrist = keypoints[10];

        const rUpperDir = computeDirection(rShoulder, rElbow);
        const rLowerDir = computeDirection(rElbow, rWrist);

        rotateBone("mixamorigRightArm", rUpperDir);
        rotateBone("mixamorigRightForeArm", rLowerDir);

        const lShoulder = keypoints[5];
        const lElbow = keypoints[7];
        const lWrist = keypoints[9];

        const lUpperDir = computeDirection(lShoulder, lElbow);
        const lLowerDir = computeDirection(lElbow, lWrist);

        rotateBone("mixamorigLeftArm", lUpperDir);
        rotateBone("mixamorigLeftForeArm", lLowerDir);

        const rHip = keypoints[12];
        const rKnee = keypoints[14];
        const rAnkle = keypoints[16];

        const rThighDir = computeDirection(rHip, rKnee);
        const rCalfDir = computeDirection(rKnee, rAnkle);

        rotateBone("mixamorigRightUpLeg", rThighDir);
        rotateBone("mixamorigRightLeg", rCalfDir);

        const lHip = keypoints[11];
        const lKnee = keypoints[13];
        const lAnkle = keypoints[15];

        const lThighDir = computeDirection(lHip, lKnee);
        const lCalfDir = computeDirection(lKnee, lAnkle);

        rotateBone("mixamorigLeftUpLeg", lThighDir);
        rotateBone("mixamorigLeftLeg", lCalfDir);

        const lShoulderKp = keypoints[5];
        const rShoulderKp = keypoints[6];
        const lHipKp = keypoints[11];
        const rHipKp = keypoints[12];

        if (
          isConfident(lShoulderKp) &&
          isConfident(rShoulderKp) &&
          isConfident(lHipKp) &&
          isConfident(rHipKp)
        ) {
          const spineMid = {
            x: (lShoulderKp.x + rShoulderKp.x) / 2,
            y: (lShoulderKp.y + rShoulderKp.y) / 2,
          };
          const hipMid = {
            x: (lHipKp.x + rHipKp.x) / 2,
            y: (lHipKp.y + rHipKp.y) / 2,
          };
          const spineDir = computeDirection(hipMid, spineMid);
          rotateBone("mixamorigSpine2", spineDir);
        }

        const noseKp = keypoints[0];
        const lEar = keypoints[3];
        const rEar = keypoints[4];

        if (isConfident(noseKp) && (isConfident(lEar) || isConfident(rEar))) {
          const refEar = isConfident(rEar) ? rEar : lEar;
          const headDir = computeDirection(refEar, noseKp);
          rotateBone("mixamorigHead", headDir);
          rotateBone("mixamorigNeck", headDir);
        }
      }

      // ===========================
      // ì•„ë°”íƒ€ ìŠ¤íƒ€ì¼ ì…€ë ‰íŠ¸ ì´ë²¤íŠ¸ ë°”ì¸ë”©
      // ===========================
      if (avatarStyleSelect) {
        avatarStyleSelect.addEventListener("change", (e) => {
          const value = e.target.value;
          if (!window.avatarInitialized) {
            initAvatarMode();
            window.avatarInitialized = true;
          }
          loadAvatarModel(value);
        });
      }
    </script>
  </body>
</html>
