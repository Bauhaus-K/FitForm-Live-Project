<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>MyPT Azure â€“ On-device Pose Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --bg: #020817;
        --card: #020617;
        --card-soft: #020617;
        --accent: #38bdf8;
        --accent-soft: rgba(56, 189, 248, 0.1);
        --text: #e5e7eb;
        --muted: #9ca3af;
        --danger: #f97373;
        --good: #22c55e;
        --border: #1f2937;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Pretendard", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background: radial-gradient(circle at top, #020617, #000);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }

      .page {
        width: 100%;
        /* í™”ë©´ì„ ë„“ê²Œ ì“°ê¸° ìœ„í•´ max-width ì¦ê°€ */
        max-width: 1600px; 
        padding: 32px 16px 64px;
      }

      header {
        margin-bottom: 24px;
      }

      .title-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
      }

      .title-row span.emoji {
        font-size: 32px;
      }

      h1 {
        font-size: 32px;
        margin: 0;
        font-weight: 700;
      }

      .subtitle {
        color: var(--muted);
        font-size: 15px;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .container-split {
        display: flex;
        gap: 20px;
        justify-content: center;
        flex-wrap: wrap; /* í™”ë©´ ì¢ìœ¼ë©´ ì•„ë˜ë¡œ ë‚´ë ¤ê° */
      }

      .video-shell {
        flex: 1;
        min-width: 320px; /* ë„ˆë¬´ ì‘ì•„ì§€ì§€ ì•Šê²Œ */
        background: radial-gradient(circle at top left, #020617, #020617 40%);
        border-radius: 24px;
        border: 1px solid var(--border);
        padding: 16px 16px 24px;
        box-shadow: 0 40px 80px rgba(0, 0, 0, 0.8);
      }

      .video-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        gap: 8px;
        flex-wrap: wrap;
      }

      .video-toolbar-left {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .pill {
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        font-size: 11px;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .pill-dot {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: #22c55e;
      }

      .exercise-select {
        background: #020617;
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 6px 10px;
        color: var(--text);
        font-size: 13px;
      }

      .exercise-select select {
        background: transparent;
        border: none;
        color: inherit;
        font: inherit;
        outline: none;
      }

      .control-group {
        display: flex;
        align-items: center;
        background: #020617;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 13px;
        color: var(--muted);
        gap: 4px;
      }
      
      .control-group input {
        background: transparent;
        border: none;
        color: white;
        width: 60px; 
        text-align: center;
        font-weight: bold;
        border-bottom: 1px solid #38bdf8;
        outline: none;
      }
      .control-group span {
        color: var(--text);
      }

      .video-wrapper {
        position: relative;
        border-radius: 18px;
        overflow: hidden;
        background: #020617;
        border: 1px solid #020617;
        aspect-ratio: 16 / 9;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      video,
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #ref-video {
        transform: none; 
      }

      canvas {
        pointer-events: none;
      }

      /* â˜… ì¶”ê°€ëœ ë¶€ë¶„: ì¤‘ì•™ ìƒë‹¨ ëŒ€í˜• ì¹´ìš´í„° ìŠ¤íƒ€ì¼ */
      .big-counter {
        position: absolute;
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 6rem;
        font-weight: 800;
        color: rgba(255, 255, 255, 0.95);
        text-shadow: 0 8px 24px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 10;
        display: flex;
        align-items: baseline;
        gap: 10px;
      }
      
      .big-counter .target-small {
        font-size: 2.5rem;
        color: var(--muted);
        font-weight: 600;
      }

      .hud-card {
        position: absolute;
        left: 24px;
        bottom: 24px;
        background: rgba(15, 23, 42, 0.96);
        border-radius: 18px;
        padding: 16px 18px 14px;
        min-width: 220px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        backdrop-filter: blur(16px);
        box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7);
        z-index: 20; /* ì¹´ìš´í„°ë³´ë‹¤ ìœ„ì— ì˜¤ê²Œ */
      }

      .hud-title {
        font-size: 15px;
        font-weight: 600;
        margin-bottom: 4px;
      }

      .hud-row {
        display: flex;
        gap: 12px;
        font-size: 13px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .hud-row strong {
        color: var(--text);
        font-weight: 600;
        margin-left: 2px;
      }

      .status-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        margin-bottom: 10px;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #4b5563;
      }

      .status-dot.good {
        background: var(--good);
      }

      .status-dot.bad {
        background: var(--danger);
      }

      .status-text {
        color: var(--muted);
      }

      .status-text strong {
        color: var(--text);
        font-weight: 600;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 7px 14px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: linear-gradient(135deg, #0ea5e9, #22c55e);
        color: white;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        outline: none;
      }

      .btn.secondary {
        background: rgba(15, 23, 42, 0.9);
        border-color: rgba(148, 163, 184, 0.5);
        color: var(--text);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: default;
      }

      @media (max-width: 768px) {
        .page {
          padding-inline: 12px;
        }
        h1 {
          font-size: 24px;
        }
        .hud-card {
          left: 14px;
          bottom: 14px;
        }
        /* ëª¨ë°”ì¼ì—ì„œëŠ” í°íŠ¸ ì‚¬ì´ì¦ˆ ì¡°ì • */
        .big-counter {
            font-size: 4rem;
        }
        .big-counter .target-small {
            font-size: 1.5rem;
        }
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
    <script src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@latest/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>
  </head>

  <body>
    <div class="page">
      <header>
        <div class="title-row">
          <span class="emoji">ğŸ‹ï¸â€â™‚ï¸</span>
          <h1>MyPT Azure â€“ On-device Pose Demo</h1>
        </div>
        <p class="subtitle">
          ë¸Œë¼ìš°ì €ì—ì„œ <strong>MoveNet</strong>ìœ¼ë¡œ íŒ” êµ½í˜€í´ê¸°(íŒ” ì»¬) / ìŠ¤ì¿¼íŠ¸ ë™ì‘ì„
          ì‹¤ì‹œê°„ìœ¼ë¡œ ì¸ì‹í•©ë‹ˆë‹¤.
        </p>
      </header>

      <main>
        <div class="container-split">
            
            <section class="video-shell">
              <div class="video-toolbar">
                <div class="video-toolbar-left">
                  <div class="pill">
                    <span class="pill-dot"></span>
                    <span id="model-label">MoveNet Lightning Â· On-device</span>
                  </div>

                  <div class="exercise-select">
                    <select id="exercise-select">
                      <option value="right_curl">Right Arm Curl</option>
                      <option value="left_curl">Left Arm Curl</option>
                      <option value="squat">Squat</option>
                      <option value="lunge_right">Right Lunge</option>
                      <option value="shoulder_press">Shoulder Press</option>
                      <option value="side_raise_right">Right Side Raise</option>
                    </select>
                  </div>

                  <div class="control-group">
                    <span>ëª©í‘œ:</span>
                    <input type="number" id="target-reps-input" value="15" min="1">
                    <span>íšŒ</span>
                  </div>
                  <div class="control-group">
                    <span>íœ´ì‹:</span>
                    <input type="number" id="rest-time-input" value="10" min="5">
                    <span>ì´ˆ</span>
                  </div>

                </div>

                <div style="display: flex; gap: 8px; align-items: center;">
                  <button id="toggle-overlay" class="btn secondary">í¬ì¦ˆì„  ë„ê¸°</button>
                  <button id="toggle-camera" class="btn">ì¹´ë©”ë¼ ì‹œì‘</button>
                </div>
              </div>

              <div class="video-wrapper">
                <video id="video" playsinline></video>
                <canvas id="canvas"></canvas>

                <div class="big-counter" id="big-counter">
                    <span id="big-reps-display">0</span>
                    <span class="target-small">/ <span id="big-target-display">15</span></span>
                </div>

                <div class="hud-card">
                  <div class="hud-title" id="hud-exercise">Right Arm Curl</div>

                  <div class="hud-row">
                    <div>Reps:<strong id="hud-reps">0</strong> / <span id="hud-target">15</span></div>
                    <div>Angle:<strong id="hud-angle">0Â°</strong></div>
                    <div>FPS:<strong id="hud-fps">0</strong></div>
                  </div>

                  <div class="status-row">
                    <div id="status-dot" class="status-dot"></div>
                    <div class="status-text">
                      ìƒíƒœ: <strong id="status-label">-</strong>
                      <span id="status-detail" style="margin-left: 4px; color: var(--muted);"></span>
                    </div>
                  </div>

                  <button id="reset-btn" class="btn secondary">ì¹´ìš´íŠ¸ ì´ˆê¸°í™”</button>
                </div>
              </div>
            </section>

            <section class="video-shell">
                <div class="video-toolbar">
                    <div class="pill">
                        <span class="pill-dot" style="background: #38bdf8;"></span>
                        <span>Reference Video</span>
                    </div>
                </div>
                <div class="video-wrapper">
                    <video id="ref-video" src="" loop muted playsinline autoplay></video>
                    
                    <div class="hud-card" style="left: 20px; bottom: 20px; min-width: auto;">
                        <div class="hud-title">Guide</div>
                        <div class="status-text" id="ref-video-label">Right Arm Curl</div>
                    </div>
                </div>
            </section>

        </div> </main>
    </div>

    <script>
        // --------------------------
        // 0. TTS ë° ë”œë ˆì´ í•¨ìˆ˜ ì„¤ì •
        // --------------------------
        let isSpeaking = false; 
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function speakText(text) {
            if (isSpeaking && text.length > 2) return; 

            // â˜…â˜…â˜… [ì¤‘ìš”] ì—¬ê¸°ì— Azure Speech ë¦¬ì†ŒìŠ¤ í‚¤ì™€ ì§€ì—­ì„ ì…ë ¥í•˜ì„¸ìš”. â˜…â˜…â˜…
            const speechConfig = SpeechSDK.SpeechConfig.fromSubscription("ì—¬ê¸°ì—_ë³µì‚¬í•œ_í‚¤_ë¶™ì—¬ë„£ê¸°", "koreacentral");
            
            speechConfig.speechSynthesisVoiceName = "ko-KR-InJoonNeural"; 

            const audioConfig = SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();
            const synthesizer = new SpeechSDK.SpeechSynthesizer(speechConfig, audioConfig);

            isSpeaking = true;

            synthesizer.speakTextAsync(
                text,
                result => {
                    if (result.reason === SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                        // console.log("ìŒì„± ì¬ìƒ ì„±ê³µ");
                    }
                    isSpeaking = false;
                    synthesizer.close();
                },
                error => {
                    console.error(error);
                    isSpeaking = false;
                    synthesizer.close();
                }
            );
        }

        // --------------------------
        // 1. ê¸°ë³¸ ìƒíƒœ & ìƒìˆ˜
        // --------------------------
        const videoEl = document.getElementById("video");
        const canvasEl = document.getElementById("canvas");
        const ctx = canvasEl.getContext("2d");

        const hudExercise = document.getElementById("hud-exercise");
        const hudReps = document.getElementById("hud-reps");
        const hudTarget = document.getElementById("hud-target");
        const hudAngle = document.getElementById("hud-angle");
        const hudFps = document.getElementById("hud-fps");
        const statusDot = document.getElementById("status-dot");
        const statusLabel = document.getElementById("status-label");
        const statusDetail = document.getElementById("status-detail");
        const toggleCameraBtn = document.getElementById("toggle-camera");
        const toggleOverlayBtn = document.getElementById("toggle-overlay");
        const resetBtn = document.getElementById("reset-btn");
        const exerciseSelect = document.getElementById("exercise-select");
        
        const targetRepsInput = document.getElementById("target-reps-input");
        const restTimeInput = document.getElementById("rest-time-input");
        
        // â˜… ì¶”ê°€ëœ ë¶€ë¶„: ëŒ€í˜• ì¹´ìš´í„° ìš”ì†Œ
        const bigRepsDisplay = document.getElementById("big-reps-display");
        const bigTargetDisplay = document.getElementById("big-target-display");

        // ì°¸ê³  ì˜ìƒ ì—˜ë¦¬ë¨¼íŠ¸
        const refVideoEl = document.getElementById("ref-video");
        const refVideoLabel = document.getElementById("ref-video-label");

        // ìš´ë™ë³„ ì°¸ê³  ì˜ìƒ ë§¤í•‘
        const VIDEO_MAP = {
            right_curl: "pushup_2.mp4",  
            left_curl: "plank_1.mp4",    
            squat: "squat_3.mp4",        
            lunge_right: "", 
            shoulder_press: "",
            side_raise_right: ""
        };

        const KEY = {
            nose: 0,
            leftEye: 1,
            rightEye: 2,
            leftEar: 3,
            rightEar: 4,
            leftShoulder: 5,
            rightShoulder: 6,
            leftElbow: 7,
            rightElbow: 8,
            leftWrist: 9,
            rightWrist: 10,
            leftHip: 11,
            rightHip: 12,
            leftKnee: 13,
            rightKnee: 14,
            leftAnkle: 15,
            rightAnkle: 16,
        };

        // --------------------------
        // 2. ìš´ë™ ì„¤ì •
        // --------------------------
        const EXERCISES = {
            right_curl: {
                name: "Right Arm Curl",
                angleJoints: [KEY.rightShoulder, KEY.rightElbow, KEY.rightWrist],
                thresholds: { up: 155, down: 60 },
                start: {
                    hint: "ì˜¤ë¥¸íŒ”ì„ ì˜†ìœ¼ë¡œ ë‚´ë ¤ ì™„ì „íˆ í¸ ìƒíƒœë¡œ ë¤ë²¨ì„ ë“¤ê³  ì„œì„¸ìš”.",
                    check(angle) {
                        return angle > 150;
                    },
                },
                feedback(angle) {
                    if (angle > 150) {
                        return {
                            label: "Ready",
                            detail: "íŒ”ì„ ì™„ì „íˆ í¸ ìƒíƒœì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤.",
                            good: false,
                        };
                    }
                    if (angle < 70) {
                        return {
                            label: "Curl",
                            detail: "ìˆ˜ì¶• êµ¬ê°„ì…ë‹ˆë‹¤. ìƒì™„ì´ í”ë“¤ë¦¬ì§€ ì•Šê²Œ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                            good: true,
                        };
                    }
                    return {
                        label: "Moving",
                        detail: "ì¢‹ì•„ìš”, ì¼ì •í•œ ì†ë„ë¡œ ì˜¬ë ¸ë‹¤ ë‚´ë¦¬ì„¸ìš”.",
                        good: true,
                    };
                },
            },
            left_curl: {
                name: "Left Arm Curl",
                angleJoints: [KEY.leftShoulder, KEY.leftElbow, KEY.leftWrist],
                thresholds: { up: 155, down: 60 },
                start: {
                    hint: "ì™¼íŒ”ì„ ì˜†ìœ¼ë¡œ ë‚´ë ¤ ì™„ì „íˆ í¸ ìƒíƒœë¡œ ë¤ë²¨ì„ ë“¤ê³  ì„œì„¸ìš”.",
                    check(angle) {
                        return angle > 150;
                    },
                },
                feedback(angle) {
                    if (angle > 150) {
                        return {
                            label: "Ready",
                            detail: "ì™¼íŒ”ì„ ì™„ì „íˆ í¸ ìƒíƒœì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤.",
                            good: false,
                        };
                    }
                    if (angle < 70) {
                        return {
                            label: "Curl",
                            detail: "ì™¼íŒ” ìˆ˜ì¶• êµ¬ê°„ì…ë‹ˆë‹¤. ì–´ê¹¨ëŠ” ê³ ì •í•˜ì„¸ìš”.",
                            good: true,
                        };
                    }
                    return {
                        label: "Moving",
                        detail: "ì¢‹ì•„ìš”, ë¦¬ë“¬ì„ ì¼ì •í•˜ê²Œ ìœ ì§€í•˜ì„¸ìš”.",
                        good: true,
                    };
                },
            },
            squat: {
                name: "Squat",
                angleJoints: [KEY.leftHip, KEY.leftKnee, KEY.leftAnkle],
                thresholds: { up: 165, down: 100 },
                start: {
                    hint: "ë°œì„ ì–´ê¹¨ë„ˆë¹„ë¡œ ë²Œë¦¬ê³  ìƒì²´ë¥¼ ì„¸ìš´ ìƒíƒœë¡œ ë˜‘ë°”ë¡œ ì„œì„¸ìš”.",
                    check(angle) {
                        return angle > 165;
                    },
                },
                feedback(angle) {
                    if (angle > 170) {
                        return {
                            label: "Stand",
                            detail: "ì™„ì „íˆ ì„œ ìˆëŠ” ìƒíƒœì…ë‹ˆë‹¤. ì¤€ë¹„ê°€ ë˜ë©´ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                            good: false,
                        };
                    }
                    if (angle < 90) {
                        return {
                            label: "Too Low",
                            detail: "ë„ˆë¬´ ë‚®ì•„ìš”. í—ˆë¦¬/ë¬´ë¦ ë¶€ë‹´ì— ì£¼ì˜í•˜ì„¸ìš”.",
                            good: false,
                        };
                    }
                    if (angle >= 90 && angle <= 110) {
                        return {
                            label: "Good Depth",
                            detail: "ì¢‹ì€ ê¹Šì´ì…ë‹ˆë‹¤. ê°€ìŠ´ì€ í´ê³  ì½”ì–´ë¥¼ ì¡°ì´ì„¸ìš”.",
                            good: true,
                        };
                    }
                    return {
                        label: "Half Squat",
                        detail: "ì¡°ê¸ˆ ë” ë‚´ë ¤ê°€ë©´ ì¢‹ì•„ìš”.",
                        good: false,
                    };
                },
            },
            lunge_right: {
                name: "Right Lunge",
                angleJoints: [KEY.rightHip, KEY.rightKnee, KEY.rightAnkle],
                thresholds: { up: 165, down: 95 },
                start: {
                    hint: "ì˜¤ë¥¸ë°œì„ ì•ìœ¼ë¡œ ë‚´ë”›ê³  ìƒì²´ë¥¼ ì„¸ìš´ ìƒíƒœë¡œ ì¤€ë¹„í•˜ì„¸ìš”.",
                    check(angle) {
                        return angle > 165;
                    },
                },
                feedback(angle) {
                    if (angle > 170) {
                        return {
                            label: "Stand",
                            detail: "ìƒì²´ë¥¼ ì„¸ìš°ê³  ì¤‘ì‹¬ì„ ì¡ì€ ë’¤ ì²œì²œíˆ ë‚´ë ¤ê°€ì„¸ìš”.",
                            good: false,
                        };
                    }
                    if (angle < 85) {
                        return {
                            label: "Too Low",
                            detail: "ë„ˆë¬´ ê¹ŠìŠµë‹ˆë‹¤. ì•ë¬´ë¦ì´ ë°œëì„ ë„˜ì§€ ì•Šê²Œ!",
                            good: false,
                        };
                    }
                    if (angle >= 90 && angle <= 110) {
                        return {
                            label: "Good Lunge",
                            detail: "ì¢‹ì•„ìš”. ìƒì²´ëŠ” ì„¸ìš°ê³  ì½”ì–´ë¥¼ ê¸´ì¥í•˜ì„¸ìš”.",
                            good: true,
                        };
                    }
                    return {
                        label: "Shallow",
                        detail: "ì¡°ê¸ˆ ë” ë‚´ë ¤ê°€ë©´ ì¢‹ì•„ìš”.",
                        good: false,
                    };
                },
            },
            shoulder_press: {
                name: "Shoulder Press",
                angleJoints: [KEY.rightShoulder, KEY.rightElbow, KEY.rightWrist],
                thresholds: { up: 160, down: 90 },
                start: {
                    hint: "ë¤ë²¨ì„ ê·€ ì˜† ì •ë„ ë†’ì´ë¡œ ë“¤ê³ , íŒ”ê¿ˆì¹˜ê°€ ëª¸ ì•ì— ì˜¤ë„ë¡ ìœ ì§€í•˜ì„¸ìš”.",
                    check(angle) {
                        return angle >= 90 && angle <= 130;
                    },
                },
                feedback(angle) {
                    if (angle > 155) {
                        return {
                            label: "Lockout",
                            detail: "íŒ”ì„ ì™„ì „íˆ ì ê·¸ì§€ ë§ê³  ì‚´ì§ êµ½í˜€ ì£¼ì„¸ìš”.",
                            good: false,
                        };
                    }
                    if (angle < 90) {
                        return {
                            label: "Bottom",
                            detail: "ì–´ê¹¨ ì•„ë˜ë¡œ ë„ˆë¬´ ë‚´ë¦¬ì§€ ì•Šê²Œ ì£¼ì˜!",
                            good: false,
                        };
                    }
                    return {
                        label: "Pressing",
                        detail: "ì²œì²œíˆ ìœ„ë¡œ ë°€ì–´ ì˜¬ë¦¬ë©° ì½”ì–´ë¥¼ ì¡°ì´ì„¸ìš”.",
                        good: true,
                    };
                },
            },
            side_raise_right: {
                name: "Right Side Raise",
                angleJoints: [KEY.rightElbow, KEY.rightShoulder, KEY.rightHip],
                thresholds: { up: 165, down: 80 },
                start: {
                    hint: "ì˜¤ë¥¸íŒ”ì„ ëª¸ ì˜†ì— ìì—°ìŠ¤ëŸ½ê²Œ ë‘ê³  ì„œì„¸ìš”.",
                    check(angle) {
                        return angle > 160;
                    },
                },
                feedback(angle) {
                    if (angle > 165) {
                        return {
                            label: "Down",
                            detail: "íŒ”ì„ ëª¸ ì˜†ì— ë‘ê³  ì¤€ë¹„í•˜ì„¸ìš”.",
                            good: false,
                        };
                    }
                    if (angle < 80) {
                        return {
                            label: "Too High",
                            detail: "ì–´ê¹¨ ë†’ì´ê¹Œì§€ë§Œ ì˜¬ë ¤ ì£¼ì„¸ìš”.",
                            good: false,
                        };
                    }
                    if (angle >= 80 && angle <= 110) {
                        return {
                            label: "Good",
                            detail: "ì¢‹ì€ ë†’ì´ì…ë‹ˆë‹¤. íŒ”ê¿ˆì¹˜ë¥¼ ì‚´ì§ êµ½í˜€ ì£¼ì„¸ìš”.",
                            good: true,
                        };
                    }
                    return {
                        label: "Raising",
                        detail: "ì–´ê¹¨ ë†’ì´ê¹Œì§€ ì²œì²œíˆ ì˜¬ë¦¬ì„¸ìš”.",
                        good: true,
                    };
                },
            },
        };

        const state = {
            currentKey: "right_curl",
            reps: 0,
            stage: "up",
            lastAngle: 0,
            fps: 0,
            lastFrameTime: performance.now(),
            running: false,
            detector: null,
            animationId: null,
            stream: null,
            showSkeleton: true,
            workoutStarted: false,
            startStableFrames: 0,
            isCountingDown: false,
            countdownValue: 0,
            
            // ì„¸íŠ¸ ì„¤ì •ê°’ ë° íœ´ì‹ ìƒíƒœ
            targetReps: 15,
            restTime: 30,
            isResting: false,
            setCount: 1,

            // â˜… ì¶”ê°€ëœ ë¶€ë¶„: TTS ë”œë ˆì´ ì œì–´ìš© ìƒíƒœ
            badPostureStartTime: 0,
        };

        // ìš´ë™ ì‹œì‘ ì „ 5ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ í•¨ìˆ˜
        async function runCountdownSequence() {
            state.isCountingDown = true;
            
            const exerciseName = EXERCISES[state.currentKey].name;
            speakText(exerciseName + " ìš´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì¤€ë¹„í•˜ì„¸ìš”.");
            // â˜… [ìˆ˜ì •] ì¹´ìš´íŠ¸ë‹¤ìš´ ì „ ëŒ€ê¸° ì‹œê°„ 5ì´ˆë¡œ ì¦ê°€
            await sleep(5000); 

            for (let i = 5; i > 0; i--) {
                state.countdownValue = i;
                speakText(String(i)); 
                await sleep(1000);
            }

            state.countdownValue = 0;
            state.isCountingDown = false;
            state.workoutStarted = true;
            speakText("ì‹œì‘!");
        }

        // ì„¸íŠ¸ ì™„ë£Œ í›„ íœ´ì‹ ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ í•¨ìˆ˜
        async function startRestSequence() {
            state.isResting = true;
            
            speakText(`${state.setCount}ì„¸íŠ¸ ì¢…ë£Œ. ${state.restTime}ì´ˆê°„ íœ´ì‹í•©ë‹ˆë‹¤.`);
            
            // íœ´ì‹ ì‹œê°„ ì¹´ìš´íŠ¸
            for (let i = state.restTime; i > 0; i--) {
                // â˜… [ìˆ˜ì •] ì¹´ë©”ë¼ ì •ì§€ ë˜ëŠ” íœ´ì‹ ì¢…ë£Œ(ìš´ë™ ë³€ê²½) ì‹œ ì¦‰ì‹œ ë£¨í”„ íƒˆì¶œ
                if (!state.running || !state.isResting) break;

                state.countdownValue = i;
                
                if (i <= 5) {
                    speakText(String(i));
                }
                await sleep(1000);
            }

            // íœ´ì‹ ì¢…ë£Œ ë¡œì§
            if (state.isResting) { // ìš´ë™ ë³€ê²½ìœ¼ë¡œ ì¸í•œ ê°•ì œ ì¢…ë£Œê°€ ì•„ë‹ ë•Œë§Œ ì‹¤í–‰
                state.isResting = false;
                state.countdownValue = 0;
                state.reps = 0; // ë ™ìˆ˜ ì´ˆê¸°í™”
                state.setCount++; // ë‹¤ìŒ ì„¸íŠ¸ë¡œ ì¦ê°€
                state.stage = "up";
                
                speakText("íœ´ì‹ ì¢…ë£Œ. ë‹¤ìŒ ì„¸íŠ¸ë¥¼ ì‹œì‘í•˜ì„¸ìš”!");
            }
        }

        // --------------------------
        // 3. ë„ìš°ë¯¸ & ìŠ¤ì¼ˆë ˆí†¤
        // --------------------------
        function toVec2(kp) {
            return [kp.x, kp.y];
        }

        function angleBetween(a, b, c) {
            const ab = [a[0] - b[0], a[1] - b[1]];
            const cb = [c[0] - b[0], c[1] - b[1]];
            const dot = ab[0] * cb[0] + ab[1] * cb[1];
            const magAB = Math.hypot(ab[0], ab[1]);
            const magCB = Math.hypot(cb[0], cb[1]);
            const cosine = dot / (magAB * magCB + 1e-6);
            const rad = Math.acos(Math.min(Math.max(cosine, -1), 1));
            return (rad * 180) / Math.PI;
        }

        const SKELETON_CONNECTIONS = [
            [KEY.leftShoulder, KEY.rightShoulder],
            [KEY.leftShoulder, KEY.leftElbow],
            [KEY.leftElbow, KEY.leftWrist],
            [KEY.rightShoulder, KEY.rightElbow],
            [KEY.rightElbow, KEY.rightWrist],
            [KEY.leftShoulder, KEY.leftHip],
            [KEY.rightShoulder, KEY.rightHip],
            [KEY.leftHip, KEY.leftKnee],
            [KEY.leftKnee, KEY.leftAnkle],
            [KEY.rightHip, KEY.rightKnee],
            [KEY.rightKnee, KEY.rightAnkle],
        ];

        // MoveNetì´ ì£¼ëŠ” í”½ì…€ ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë§¤í•‘
        function projectToCanvas(kp) {
            const nx = kp.x / videoEl.videoWidth;
            const ny = kp.y / videoEl.videoHeight;
            return {
                x: nx * canvasEl.width,
                y: ny * canvasEl.height,
            };
        }

        function drawSkeleton(keypoints) {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

            if (!state.showSkeleton) {
                return;
            }

            keypoints.forEach((kp) => {
                if (!kp) return;
                if (kp.score < 0.3) return;

                const { x, y } = projectToCanvas(kp);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = "#38bdf8";
                ctx.fill();
            });

            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(56, 189, 248, 0.9)";
            SKELETON_CONNECTIONS.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                if (!kp1 || !kp2) return;
                if (kp1.score < 0.3 || kp2.score < 0.3) return;

                const p1 = projectToCanvas(kp1);
                const p2 = projectToCanvas(kp2);

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
        }
        
        function drawCountdown() {
            if (state.countdownValue > 0) {
                ctx.save();
                
                const cx = canvasEl.width / 2;
                const cy = canvasEl.height / 2;
                ctx.translate(cx, cy);
                
                ctx.scale(-1, 1);

                ctx.font = "bold 150px Pretendard";
                ctx.fillStyle = "#38bdf8";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                ctx.lineWidth = 5;
                ctx.strokeStyle = "black";
                ctx.strokeText(state.countdownValue, 0, 0);
                
                ctx.fillText(state.countdownValue, 0, 0);

                if (state.isResting) {
                    ctx.font = "bold 40px Pretendard";
                    ctx.fillStyle = "white";
                    ctx.fillText("REST TIME", 0, 80);
                }

                ctx.restore();
            }
        }

        // í¬ì¦ˆì„  í† ê¸€ ë²„íŠ¼
        toggleOverlayBtn.addEventListener("click", () => {
            state.showSkeleton = !state.showSkeleton;
            toggleOverlayBtn.textContent = state.showSkeleton ? "í¬ì¦ˆì„  ë„ê¸°" : "í¬ì¦ˆì„  ì¼œê¸°";
            if (!state.showSkeleton) {
                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            }
        });

        function updateHUD(angle, feedback) {
            hudReps.textContent = state.reps;
            hudTarget.textContent = state.targetReps;
            hudAngle.textContent = `${Math.round(angle)}Â°`;
            hudFps.textContent = state.fps.toFixed(0);
            statusLabel.textContent = feedback.label;
            statusDetail.textContent = feedback.detail;
            statusDot.classList.remove("good", "bad");
            if (feedback.good) statusDot.classList.add("good");
            else statusDot.classList.add("bad");

            // â˜… ì¶”ê°€ëœ ë¶€ë¶„: ëŒ€í˜• ì¹´ìš´í„° í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            bigRepsDisplay.textContent = state.reps;
            bigTargetDisplay.textContent = state.targetReps;
        }

        function resetCounter() {
            state.reps = 0;
            state.stage = "up";
            state.lastAngle = 0;
            state.workoutStarted = false;
            state.startStableFrames = 0;
            state.isCountingDown = false;
            state.isResting = false; 
            state.countdownValue = 0;
            // state.setCount = 1; // ë¦¬ì…‹ ë²„íŠ¼ ëˆ„ë¥¼ë•Œë§Œ ì´ˆê¸°í™”í•˜ë„ë¡ ì•„ë˜ ë¦¬ìŠ¤ë„ˆì— ì¶”ê°€í•¨

            // â˜… ì¶”ê°€ëœ ë¶€ë¶„: TTS íƒ€ì´ë¨¸ ì´ˆê¸°í™”
            state.badPostureStartTime = 0;

            statusLabel.textContent = "-";
            statusDetail.textContent = "";
            statusDot.classList.remove("good", "bad");

            hudReps.textContent = "0";
            hudAngle.textContent = "0Â°";
            
            // â˜… ì¶”ê°€ëœ ë¶€ë¶„: ëŒ€í˜• ì¹´ìš´í„° ì´ˆê¸°í™”
            bigRepsDisplay.textContent = "0";
        }

        // --------------------------
        // 4. ì¹´ìš´íŒ… & MoveNet
        // --------------------------
        function updateRepsForExercise(ex, angle) {
            if (state.isResting) return;

            const { up, down } = ex.thresholds;
            if (angle > up) {
                state.stage = "up";
            }
            if (angle < down && state.stage === "up") {
                state.stage = "down";
                state.reps += 1;
                
                // ëª©í‘œ íšŸìˆ˜ ë„ë‹¬ ì‹œ
                if (state.reps >= state.targetReps) {
                    startRestSequence();
                } else {
                    if (state.reps > 0 && state.reps % 10 === 0) {
                        speakText(state.reps + "íšŒ");
                    }
                }
            }
        }

        async function createDetector() {
            const model = poseDetection.SupportedModels.MoveNet;
            const detectorConfig = {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
            };
            return poseDetection.createDetector(model, detectorConfig);
        }

        // --------------------------
        // 5. ë©”ì¸ ë£¨í”„
        // --------------------------
        async function renderLoop() {
            if (!state.detector || !state.running) return;

            const now = performance.now();
            const dt = now - state.lastFrameTime;
            state.lastFrameTime = now;
            state.fps = 1000 / dt;

            const poses = await state.detector.estimatePoses(videoEl, {
                maxPoses: 1,
                flipHorizontal: true,
            });

            if (poses.length > 0) {
                const kp = poses[0].keypoints;
                const ex = EXERCISES[state.currentKey];
                const [ia, ib, ic] = ex.angleJoints;

                const a = toVec2(kp[ia]);
                const b = toVec2(kp[ib]);
                const c = toVec2(kp[ic]);

                const angle = angleBetween(a, b, c);
                state.lastAngle = angle;
                
                drawSkeleton(kp);

                if (state.isCountingDown || state.isResting) {
                    drawCountdown();
                    
                    let statusMsg = state.isResting ? `Resting (Set ${state.setCount})` : "Getting Ready";
                    let detailMsg = state.isResting ? "ë‹¤ìŒ ì„¸íŠ¸ë¥¼ ìœ„í•´ íœ´ì‹ ì¤‘..." : "ì¤€ë¹„í•˜ì„¸ìš”...";
                    
                    updateHUD(angle, { 
                        label: statusMsg, 
                        detail: detailMsg, 
                        good: true 
                    });
                    
                } else if (!state.workoutStarted) {
                    let ok = false;
                    if (ex.start && typeof ex.start.check === "function") {
                        ok = ex.start.check(angle, kp);
                    } else {
                        ok = angle > ex.thresholds.up - 5;
                    }

                    if (ok) state.startStableFrames += 1;
                    else state.startStableFrames = 0;

                    if (state.startStableFrames >= 8) {
                        state.startStableFrames = 0;
                        runCountdownSequence();
                    }

                    const fb = {
                        label: ok ? "Hold start position" : "Set start position",
                        detail: ex.start?.hint || "ì¤€ë¹„ìì„¸ë¥¼ ë§ì¶° ì£¼ì„¸ìš”. (ì •ë©´ì„ ë³´ê³  í™”ë©´ ì¤‘ì•™ì— ì„œì„¸ìš”.)",
                        good: ok,
                    };
                    updateHUD(angle, fb);
                } else {
                    updateRepsForExercise(ex, angle);
                    const fb = ex.feedback(angle);
                    updateHUD(angle, fb);

                    // â˜… ì¶”ê°€ëœ ë¶€ë¶„: TTS ì½”ì¹­ ë¡œì§ (3ì´ˆ ì´ìƒ ìì„¸ ì˜¤ë¥˜ ì‹œ ë§í•˜ê¸°)
                    if (!fb.good) {
                        if (state.badPostureStartTime === 0) {
                            // ì²˜ìŒ ë‚˜ìœ ìì„¸ ê°ì§€ ì‹œ ì‹œê°„ ê¸°ë¡
                            state.badPostureStartTime = performance.now();
                        } else {
                            const elapsed = performance.now() - state.badPostureStartTime;
                            if (elapsed > 3000) { // 3ì´ˆ(3000ms) ê²½ê³¼ í™•ì¸
                                speakText(fb.detail);
                                state.badPostureStartTime = 0; // ë§í–ˆìœ¼ë©´ íƒ€ì´ë¨¸ ì´ˆê¸°í™” (ê³„ì† ë§í•˜ê¸° ë°©ì§€)
                            }
                        }
                    } else {
                        // ìì„¸ê°€ ì¢‹ì•„ì§€ë©´ íƒ€ì´ë¨¸ ì´ˆê¸°í™”
                        state.badPostureStartTime = 0;
                    }
                }
            } else {
                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                statusLabel.textContent = "No pose";
                statusDetail.textContent =
                    "ì‚¬ëŒì´ í™”ë©´ ì•ˆì— ìˆë„ë¡ ìœ„ì¹˜ë¥¼ ì¡°ì •í•˜ì„¸ìš”.";
                statusDot.classList.remove("good", "bad");
            }

            state.animationId = requestAnimationFrame(renderLoop);
        }

        // --------------------------
        // 6. ì¹´ë©”ë¼ ì‹œì‘/ì •ì§€
        // --------------------------
        async function startCamera() {
            if (state.running) return;
            try {
                toggleCameraBtn.disabled = true;
                toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...";

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: false,
                });
                state.stream = stream;
                videoEl.srcObject = stream;

                await videoEl.play();

                canvasEl.width = videoEl.videoWidth;
                canvasEl.height = videoEl.videoHeight;

                if (!state.detector) {
                    state.detector = await createDetector();
                }

                state.running = true;
                state.lastFrameTime = performance.now();
                toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì •ì§€";
                toggleCameraBtn.disabled = false;
                
                state.targetReps = parseInt(targetRepsInput.value) || 15;
                state.restTime = parseInt(restTimeInput.value) || 30;
                
                // ì‹œì‘ ì‹œ ì˜ìƒ ì„¤ì •
                updateRefVideo(state.currentKey);

                renderLoop();
            } catch (err) {
                console.error(err);
                alert("ì¹´ë©”ë¼ ì ‘ê·¼ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.");
                toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì‹œì‘";
                toggleCameraBtn.disabled = false;
            }
        }

        function stopCamera() {
            state.running = false;
            if (state.animationId) cancelAnimationFrame(state.animationId);
            if (state.stream) {
                state.stream.getTracks().forEach((t) => t.stop());
                state.stream = null;
            }
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            toggleCameraBtn.textContent = "ì¹´ë©”ë¼ ì‹œì‘";
            
            // ì´ˆê¸°í™” ë¡œì§
            resetCounter();
            state.setCount = 1; // ì„¸íŠ¸ ì¹´ìš´íŠ¸ë„ 1ë¡œ ë¦¬ì…‹
        }

        // ì°¸ê³  ì˜ìƒ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateRefVideo(key) {
            const videoFile = VIDEO_MAP[key];
            if (videoFile) {
                refVideoEl.src = videoFile;
                refVideoEl.play().catch(e => console.log("Autoplay blocked", e));
            } else {
                refVideoEl.src = ""; // ë¹„ë””ì˜¤ ì—†ìŒ
            }
            refVideoLabel.textContent = EXERCISES[key].name;
        }

        // --------------------------
        // 7. ì´ë²¤íŠ¸ ë°”ì¸ë”©
        // --------------------------
        toggleCameraBtn.addEventListener("click", () => {
            if (!state.running) startCamera();
            else stopCamera();
        });

        resetBtn.addEventListener("click", () => {
            resetCounter();
            state.setCount = 1; // ë¦¬ì…‹ ë²„íŠ¼ ëˆ„ë¥´ë©´ ì„¸íŠ¸ë„ ì´ˆê¸°í™”
        });

        exerciseSelect.addEventListener("change", (e) => {
            const key = e.target.value;
            state.currentKey = key;
            resetCounter();
            state.setCount = 1; // ìš´ë™ ì¢…ëª© ë°”ë€Œë©´ ì„¸íŠ¸ë„ ì´ˆê¸°í™”

            const ex = EXERCISES[key];
            hudExercise.textContent = ex.name;
            statusLabel.textContent = "Set start position";
            statusDetail.textContent =
                ex.start?.hint || "ì¤€ë¹„ìì„¸ë¥¼ ë§ì¶° ì£¼ì„¸ìš”.";
            
            // ìš´ë™ ë°”ë€” ë•Œ ì˜ìƒë„ êµì²´
            updateRefVideo(key);
        });
        
        targetRepsInput.addEventListener("change", (e) => {
            state.targetReps = parseInt(e.target.value);
            hudTarget.textContent = state.targetReps;
            // â˜… ì¶”ê°€ëœ ë¶€ë¶„: ëŒ€í˜• íƒ€ê²Ÿ ìˆ«ì ì—…ë°ì´íŠ¸
            bigTargetDisplay.textContent = state.targetReps;
        });
        restTimeInput.addEventListener("change", (e) => {
            state.restTime = parseInt(e.target.value);
        });

        // ì´ˆê¸° HUD
        hudExercise.textContent = EXERCISES[state.currentKey].name;
        hudTarget.textContent = state.targetReps;
        bigTargetDisplay.textContent = state.targetReps; // â˜… ì´ˆê¸°ê°’ ë°˜ì˜
        
        // ì´ˆê¸° ì˜ìƒ ì„¤ì •
        updateRefVideo(state.currentKey);

    </script>
  </body>
</html>